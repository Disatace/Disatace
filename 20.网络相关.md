# 20.网络相关

![tcp工具集](https://img-blog.csdnimg.cn/20210416093754639.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4cG9pdQ==,size_16,color_FFFFFF,t_70)



# OSI七层，TCP四层

**OSI七层模型**（Open System Interconnect）即开放系统互连参考模型，是由**ISO**（International Organization for Standardization）**国际标准化组织**提出的，用于计算机或通信系统间互联的标准体系。

从上到下可分为七层：**每一层都完成特定的功能，并为上一层提供服务，并使用下层所提供的服务。**

7、应用层（Application）：为用户的应用程序提供网络服务
6、表示层（Presentation）：将信息表示为一定形式和格式的数据流
5、会话层（Session）：负责通信主机之间会话的建立、管理和拆除，协调通信双方的会话
4、传输层（Transport）：负责通信主机间端到端的连接
3、网络层（Network）：负责将分组从源机送到目的机，包括寻址和最优路径选择等
2、数据链路层（Data Link）：提供可靠的帧传递，实现差错控制、流控等等
1、物理层（Physical）：提供透明的**比特流（01流）传递**

![img](https://pic3.zhimg.com/80/v2-1ebda43e282ef7b086285563fa32a8c6_720w.jpg)



### 应用层

应用层是最靠近用户的一层，为计算机用户提供应用接口，也为用户直接提供各种网络服务，这一层常见的网络协议有：**HTTP 、HTTPS、FTP、SMTP 等。**

例如用户 A 在主机 A 上新建一封电子邮件，指定收件人为 B，输入邮件内容 ：”开开心心“。

当用户输入完后点击发送的那一刻开始，就进入了应用层协议的处理。

该层协议会在所要发送的数据前端附加一个首部信息。首部消息表明了要发送的内容和要发送到的地方。

### 表示层

表示层更关注数据的具体表现形式。提供各种用于应用层数据的编码和转换功能，确保一个系统的应用层发送的数据能被另一个系统的应用层识别。

如果用户 A 是通过 QQ 邮箱发送的，而用户 B 是通过 网易邮箱接收的，那么因为两者邮件客户端不一致，为了能够顺利收取和阅读邮件，会将数据格式转换为 网络通用的标准数据格式发送出去，接收端收到数据后再将这些通用标准数据转换为自己特定的数据格式再进行相应处理。

表示层与表示层之间为了识别编码格式也会附加首部信息，从而将实际传输的数据转交给下一层去处理。

### 会话层

 会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。

假设用户 A 新建了 5 封邮件准备发给用户 B。例如，可以每发一封邮件时建立一次连接，随后断开连接。还可以已经一经建立好连接就将 5 封邮件连续发送给对方。决定采用何种连接方法是会话层的主要责任。

会话层也会像应用层或表示层那样，在收到的数据前端附加首部或标签信息再转给下一层。

### 传输层

主机 A 确保与主机 B 之间的通信并准备发送数据。这个过程叫 建立连接。有了这个连接主机 A发送的邮件就可以到主机 B。此外，当通信传输结束后，有必要将连接断开。

如上，进行建立连接或断开连接的处理，在两个主机之间创建逻辑上的通信连接是传输层的主要作用。如果数据没有到达，它还会负责重发，保证数据传输的可靠性。

该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，TCP UDP就是在这一层。

### 网络层

网络层的作用是在网络与网络相互连接的环境中，将数据从发送端主机发送到接收端主机。这一层主要用到的协议就是 IP 协议。

IP 协议使数据能够发送到地球的另一端，这期间它使用 IP 地址作为主机的标识。还有一个 ICMP 也需要关注下，IP 数据包如果在发送途中出现异常无法到达对端目标地址时，需要给发送端一个发送异常通知，ICMP 就是为这一功能而制定的。

网络层就相当于快递公司庞大的快递网络，全国不同的集散中心，比如说，从上海发往北京的顺丰快递，首先要到顺丰的上海集散中心，从上海集散中心再送到河北保定集散中心，从保定集散中心再寄到北京顺义集散中心。这个每个集散中心，就相当于网络中的一个IP节点。

### 数据链路层

将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。

在计算机网络中由于各种干扰的存在，物理链路是不可靠的。因此，这一层的主要功能是在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路，即提供可靠的通过物理介质传输数据的方法。
该层通常又被分为介质访问控制（MAC）和逻辑链路控制（LLC）两个子层。

MAC子层的主要任务是解决共享型网络中多用户对信道竞争的问题，完成网络介质的访问控制；

LLC子层的主要任务是建立和维护网络连接，执行差错校验、流量控制和链路控制。
数据链路层的具体工作是接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层；并且，还负责处理接收端发回的确认帧的信息，以便提供可靠的数据传输。

### 物理层

实际最终信号的传输是通过物理层实现的。主要功能就是利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。

通过物理介质传输比特流。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。


## 物理层 

- 不管通过什么样的介质，将信息的二进制能够传递到另外一个节点，这个过程就是物理层 
- 物理层定义了一系列传输介质的电气标准，这个是弱电工程师关心的 
  - RJ45俗称水晶头 T568B 
    - 线序标准，目前市场上绝大多数网线是这个标准 
      - 橙白 橙 绿白 蓝 蓝白 绿 棕白 棕 
    - T568A 
  - SFP 
    - SFP看拉环颜色 
      - LC连接器，进出分开 
      - SC连接器，单根纤进出



# ip地址

- IP地址是32位二进制，类似手机号码有归属地和号码字段，归属地字段一样，说明在同一个运营商 同一个封你为 
- 为了让人类能够记住，不眼花，使用点分十进制

- p地址网络位 
  - IP地址网络位表示一样是同一个局域网的 
  - 局域网是多台设备组成，可以直接不受控制的访问 
  - 正常情况下，一家公司为了安全、财务、研发、it、业务等部门之间相互隔离或者受控

- ip地址主机位 
  - 在网络位相同的情况下（也就是一个局域网），主机位不能重复 
  - 主机位是为了帮助局域网内的设备相互之间进行更高层的通信封装使用

- 网络类型
  -  A：1.0.0.0~126.255.255.255/8 
    - 127开头的作为本地的测试地址 
    - A类地址的局域网可以存在2^24-2个主机 
  - B：128.0.0.0~191.255.255.255/16 
    - B类地址的局域网可以存在2^16-2个主机 
  - C：192.0.0.0~223.255.255.255/24 C类地址的局域网可以存在2^8-2个主机 
  - D组播没有网络位概念 
  - E用不到 
  - 使用子网掩码来区分网络位和主机位，因为有类的方式使用ip地址空间太土豪 
  - 子网掩码可以让ip地址自由的划分网络位数，子网掩码也是32位二进制，所以可以和IP地址进 行一一对应，规定子网掩码为1，那么所对应的IP地址就是属于网络位

![image-20220428113250976](http://cdn.gtrinee.top/image-20220428113250976.png)

## 子网掩码(Netmask) 

- 网络掩码与IP地址搭配使用，用于描述一个IP地址中的网络部分及主机部分 
- 网络掩码32bits，与32bits的IP地址一一对应，掩码中为1的位对应IP地址中的网络位，掩码中为0 的位对应IP地址中的主机位

 ![image-20220428151346223](http://cdn.gtrinee.top/image-20220428151346223.png)

# 3.TCP三次握手四次挥手详解

TCP三次握手的过程如下:

建立TCP连接，就是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发。

在TCP/IP协议中,TCP协议提供可靠的连接服务,采用三次握手建立一个连接.

第一次握手：**Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认**。

**SYN：同步序列编号(Synchronize Sequence Numbers)**

第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，**Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K**，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。

第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。

![img](https://pic2.zhimg.com/80/v2-08a83a15cf9060013484ffc688528829_720w.jpg)

> 为什么需要三次握手，是为了解决下列的一个问题:
>
> client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用三次握手，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用三次握手的办法可以防止上述现象发生

TCP四次挥手的过程如下: 

这由TCP的半关闭（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。

TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务器均可主动发起挥手动作



![img](https://pic2.zhimg.com/v2-c7d4b5aca66560365593f57385ce9fa9_b.jpg)



刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：

第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。

即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。

第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。

即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。

第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。

即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。

第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。

即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。**此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。**

收到一个FIN只意味着在这一方向上没有数据流动。客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。

在socket编程中，任何一方执行close()操作即可产生挥手操作。

# 数据封装

![image-20220428152019411](http://cdn.gtrinee.top/image-20220428152019411.png)

- 数据从产生到传递到目的地的过程中会经历好几个过程，每个过程都负责加工自己这部分的内容， 类似于工厂流水线 
- 目前我们只需要有个最基本的概念： 
  - IP地址是用来标识网络中位置的，比如你在江苏省xxx市xxx路xxx号 
  - MAC地址是每个网络设备的唯一ID，比如你的身份证号码 
  - 如果想要发送数据，必须(暂且认为必须)同时拥有IP和MAC地址 
  - Linux的网络管理基础部分就是需要大家掌握IP地址的配置 

数据解封装的过程和数据封装过程正好相反，数据封装是由发送者执行，数据解封装是由接收者执行

# 数据报文

#### **OSI参考模型和TCP/IP参考模型**

![img](https://images2015.cnblogs.com/blog/799532/201703/799532-20170317130242510-1648057613.png)

![img](https://images2015.cnblogs.com/blog/799532/201703/799532-20170316181554713-339104770.png)

![image-20220428152820864](http://cdn.gtrinee.top/image-20220428152820864.png)

# 环回接口

- Loopback接口，也叫环回口，是一个**逻辑的、虚拟的接口**；
-  使用全局配置命令interface loopback 加上接口编号可创建一个Loopback接口，创建完成后即可 为接口配置IP地址； 
- Loopback接口在手工创建后，除非人为shutdown，否则不会DOWN掉； 
- Loopback接口常用于： 
  - 模拟路由器的直连网段，可用于测试； 
  - 可用于设备管理（Loopback接口比较稳定）； 
  - 供其他协议使用，例如OSPF、BGP、MPLS等；
  -  SNMPTraps消息的源地址； 
  - 其他用途（Loopback接口的用途十分广泛

# 路由汇总

**1、****路由汇总技术背景**

![img](http://support.huawei.com/huaweiconnect/enterprise/data/attachment/forum/dm/ecommunity/uploads/2014/0619/10/53a25203250a8.png)

我们看上图，对于R1而言，如果要去往R2身后的172.16.1.0/24、172.16.2.0/24、172.16.3.0/24网络，那么自然是要有路由的，如果是采用静态路由的方式，意味着我们要给R1配置三条静态路由分别对应上述三个网段，上面我们已经说过了，这样的配置，一来工作量大，想想看，如果R2身后不仅仅有三个网络呢？如果有100个网络呢？再者这也意味着R1的路由表变得非常臃肿。
在上一小节我们已经介绍过默认路由了，默认路由固然可以解决一部分的问题，但是默认路由的“路由颗粒度”太大，无法做到对路由更为细致的控制，而且如果R1左侧连接了一 个网络出口并且已经占用了默认路由了，那么这里只能另想他法了。
路由汇总可以很好的解决这个问题：

![img](http://support.huawei.com/huaweiconnect/enterprise/data/attachment/forum/dm/ecommunity/uploads/2014/0619/10/53a2520fad418.png)

前一个场景，我们需使用3条明细路由，而在上图R1中，我们却仅仅使用一条路由即可实现相同的效果，这条路由是上一个场景中三条明细路由的汇总路由。这样配置的一个直接好处就是，路由器的路由表条目大大减少了。这种操作方式我们称为路由汇总。路由汇总是一个非常重要的网络设计思想，通常在一个大中型的网络设计中，必须时刻考虑网络及路由的可优化性，路由汇总就是一个我们时常需要关注的工具。这里实际上是部署了静态路由的汇总，当然除此之外我们也可以在动态路由协议中进行路由汇总，几乎所有的动态路由协议都支持路由汇总。

**2、****路由精确汇总的算法**

路由的汇总实际上是通过对子网掩码的操作来完成的。对于下面的例子来说：

![img](http://support.huawei.com/huaweiconnect/enterprise/data/attachment/forum/dm/ecommunity/uploads/2014/0619/10/53a2522765c69.png)

在R2上，为了到达R1下联的网络，R2使用路由汇总的工具，指了一条汇总路由：

[R2] ip route-static 172.16.0.0 16 10.1.12.1                #12.1为R1的接口IP

虽然这确实起到了网络优化的目的，但是，这条汇总路由太“粗犷”了，它甚至将R3这一侧的网段也囊括在内，我们称这种路由汇总行为不够精确。因此，一种理想的方式是，使用一个“刚刚好”囊括这些明细路由的汇总路由，这样一来就可以避免汇总不够精确的问题。
这里不得不强调一点，网络可以部署路由汇总的前提是我们网络中IP子网及网络模型设计具备一定的科学性和合理性，因此路由汇总和网络的IP子网及网络模型的设计是息息相关的。如果你的网络规划的杂乱无章，路由汇总部署起来就相当的困难了。
那么如何进行汇总路由的精确计算呢?下面我们来看一个例子：
现有明细路由：172.16.1.0/24至172.16.31.0/24，计算最精确的汇总路由

![img](http://support.huawei.com/huaweiconnect/enterprise/data/attachment/forum/dm/ecommunity/uploads/2014/0619/11/53a2523d0e917.png)

我们要做的事情非常简单，这些个明细子网是连续的，我们只要挑出首位的两到三个网络号来计算就足够了：

1. 将这些IP地址写成二进制形式，实际上，我们只要考虑第三个8位组即可，因为只有它是在变化的。
2. 现在，我们要画一根竖线，这根线的左侧，每一个列的二进制数都是一样的，线的右侧则无所谓，可以是变化的，这根线的最终位置，就是汇总路由的掩码长度。注意这根竖线可以从默认的掩码长度，也就是/24开始，一格一格的往左移，直到你观察到线的左端每一列数值都相等，即可停下，这时候，这根线，所处的位置就刚刚好。
3. 如上图，线的位置是16+3=19，所以我们得到汇总地址：172.16.0.0/19，这就是一个最精确的汇总地址。

因此，上面的例子，我们可以这么配置：

![img](http://support.huawei.com/huaweiconnect/enterprise/data/attachment/forum/dm/ecommunity/uploads/2014/0619/11/53a2525ed5c81.png)

 

**3、****路由汇总的潜在问题**

![img](http://support.huawei.com/huaweiconnect/enterprise/data/attachment/forum/dm/ecommunity/uploads/2014/0619/11/53a25279a4624.png)

 

路由汇总是一个非常重要的网络优化工具，然而如果使用不当，也有可能带来问题，在上图中，R1左侧有192.168开头的一系列网络，为了让他们能够访问Internet，R1配置了指向R2的默认路由。而R2为了让数据能够回程，又为了精简路由表，配置了一条汇总路由192.168.0.0/16，并指向R1。这个网络看似没什么问题，但……

![img](http://support.huawei.com/huaweiconnect/enterprise/data/attachment/forum/dm/ecommunity/uploads/2014/0619/11/53a2528abe357.png)

 

解决办法：

![img](http://support.huawei.com/huaweiconnect/enterprise/data/attachment/forum/dm/ecommunity/uploads/2014/0619/11/53a25299d3e21.png)

 

在R1上配置一条ip route-static 192.168.0.0 16 null0，即可解决上述问题，当R1收到扫描报文发往192.168网络下不存在的目的时，就会直接被R1丢弃，而不会再转发给R2了。这就解决了理由环路的问题。这个思路在路由汇总的时候非常关键，许多动态路由协议在使用命令执行路由汇总的时候，会在本地路由表中产生一条指向null0的汇总路由就是这个原因。
因此，无论是采用静态路由，或者是动态路由协议来部署路由汇总，都应格外留意路由汇总是否可能引发路由环路

# 网络相关笔记

```
============初始化========

no 

en
conf t
no cdp run
interface range e0/0 -3
duplex full
no ip do lo
line co 0
exec-t 0
logg sy
ho R

=========配置telnet服务======
line vty 0 4
pass cisco
login
tran in telnet

========配置ssh服务===========
hostname ISP2
ip domain name isp2.com
crypto key generate rsa
1024
username root privilege 15 secret 123456
line vty 0 4
exec-timeout 0 0
logg sy
login local
transport input ssh

=========配置静态NAT=======
int e0/0
ip nat outside
int e0/1
ip nat inside
ip nat inside source static 192.168.23.3 100.12.12.3
show ip nat translations
========静态路由==========
ip route <目标网段> <子网掩码> <出口/下一跳IP地址>

========NAT端口映射========
int e0/0
ip nat outside
int e0/1
ip nat inside
clear ip nat translation *		# 清空NAT映射表
ip nat inside source static tcp 192.168.23.3 23 interface e0/0 10023
ip nat inside source static tcp 192.168.23.5 23 interface e0/0 20023

==========PAT=============
int e0/0
ip nat outside
int e0/1
ip nat inside
access-list 1 permit 192.168.23.0 /24
ip nat inside source list 1 interface e0/0 overload

========DNAT实现负载均衡==========
int e0/0
ip nat outside
int e0/1
ip nat inside
access-list 2 permit 100.12.12.2
ip nat pool natpool 192.168.23.3 192.168.23.4 netmask 255.255.255.0 type rotary
ip nat inside destination list 2 pool natpool

========开启域名解析功能======
ip domain lookup
ip name-server <DNS服务器地址>

========开启DNS服务=========
ip dns server
ip host baidu.com 100.12.12.1

===========DHCP============
ip dhcp pool <池的名字>
network <网段> <子网掩码>
dns-server <主DNS> <备用DNS>
default-route <网关IP>
ip dhcp excluded-address <排除的地址范围> 

int e0/0
ip address dhcp

===========DHCP绑定IP=========
show ip dhcp binding 		# 查看DHCP的绑定情况，得到设备的身份证明信息
clear ip dhcp binding *		# 不清空对应的绑定项，可能导致无法绑定
ip dhcp pool <池的名字>
host <IP地址>
client-identifier <输入ID>
hardware-address	<输入mac地址>		# ID和MAC二选一
dns-server <主DNS> <备用DNS>
default-route <网关IP>

===========DHCP中继=============
int e0/0
ip help-address <DHCP地址>		# 配置在局域网的网关接口上

===========RIP相关命令=============
router rip			# 启动RIP协议
version 2			# 改成v2的版本
no auto-summary		# 关闭自动汇总，只有v2支持
network <加入RIP传递的IP网段>
default-information originate	# 通告默认路由
passive-interface e0/0		# 被动接口
neighbor <指定邻居>		# 单播更新

int e0/0
ip summary-address rip 172.16.0.0 255.255.0.0 		# 手动汇总路由

int e0/0
ip rip authentication mode text		# 明文认证
ip rip authentication key-chain <钥匙环名字>

int e0/0
ip rip authentication mode md5		# 明文认证
ip rip authentication key-chain <钥匙环名字>

access-list 1 permit 1.1.1.0
router rip
offset-list 1 out 14		# 在出口方向更新列表1里面路由的时候，度量值+14



=========key chain===============
key chain cisco
 key 1
  key-string cisco
  accept-lifetime <起始时间> <结束时间>	# 能够被匹配的时间
  send-lifetime <起始时间> <结束时间>	# 发送的时间

=========EIGRP相关命令============
router eigrp <自制系统号>
network <通告的网段>
metric maximum-hops 255
eigrp stub

interface Ethernet0/0
 ip summary-address eigrp 100 0.0.0.0 0.0.0.0

interface Ethernet0/0
 ip authentication mode eigrp 100 md5
 ip authentication key-chain eigrp 100 cisco

show ip eigrp neighbors
show ip eigrp topology
show ip eigrp topology all-links

===========OSPF相关命令============
router ospf 1
network 192.168.12.0 0.0.0.255 area 0    # 在协议下可以宣告网段

int range e0/0 -1 , lo0
ip ospf 1 area 0		# 在接口下配置ospf
ip ospf network point-to-point	# 把接口网络类型设置为点对点
ip ospf priority 10		# 修改选举DR的优先级
area 1 virtual-link 3.3.3.3	# 跨越区域1，和route-id为3.3.3.3的路由器建立虚链路
area 1 virtual-link 3.3.3.3 authentication key-chain cisco		# 可选，给虚链路加上密码

clear ip ospf process	# 重置ospf进程
show ip ospf int e0/0	# 查看接口下OSPF相关的信息
sh ip ospf database [LSA类型]  [Link-ID]

interface Ethernet0/0
 ip ospf authentication message-digest
 ip ospf message-digest-key 1 md5 [密码]

========ipip隧道配置==================
interface Tunnel0
 ip address 172.16.23.3 255.255.255.0
 tunnel source Ethernet0/0
 tunnel mode ipip
 tunnel destination 192.168.23.2

```









# 思科命令简介

### show ip route详解

```bash
R2#show ip route ?
  WORD       Network to display information about or hostname   #显示有关或主机名的信息的网络
  bgp        Border Gateway Protocol (BGP)                      #BGP协议是用于自治系统AS之间的动态路由协议
  connected  Connected   #直连
  eigrp      Enhanced Interior Routing Protocol (EIGRP)   #EIGRP协议是一种综合的路由选择协议
  ospf       Open Shortest Path First (OSPF)              #OSPF是一种链路状态型路由选择协议
  rip        Routing Information Protocol (RIP)           #RIP动态路由选择协议
  static     Static routes         #静态路由
  summary    Summary of all routes #所有路线汇总
  |          Output Modifiers

```

在show ip route命令的输出中，会列出关于路由类型的简写代码，包括：I, R, O, C, S, E, B, i等。它们的含义分别为：



> I，指从内部网关协议（IGRP）中学到的路由。
> R，从RIP协议中学到的路由。
> O，从OSPF（开放式最短路径优先）协议学到。
> C，直连路由。
> S，静态配置的路由，请注意，静态路由的管理距离为 0。
> E，从外部网关协议（EGP）学到的路由。
> B，指从BGP协议、
> I，指IS-IS协议学到的路由信息。



Cisco设备主要有如下三种模式

 `> 用户模式，`在这个模式下只能进行有限的查看与测试，不能修改和重启设备。 

`#特权模式`，这这个模式下能进行完整的查看与测试，并且允许恢复出厂设

置与重启。

 (xxxx)#各种配置模式，在()中的内容就是提示你当前在什么模块下，下面列出常见子配置模式 R1(config)#全局配置模式，可以配置设备的属性，比如设备名称之类的，并且只有全局配置模式才可以 进入到其他的子配置模式 R1(config-if)#接配置模式，可以配置这个接口的属性，比如接IP地址，接口状态等等 R1(dhcp-config)# DHCP配置模式，可以修改这个DHCP池的属性，下面就不一一举例了

```bash
路由器的基本配置
1.从用户模式进入特权模式
R1>enable

2.从特权模式进入全局配置模式
R1#configure terminal

3.设置主机名
 R1(config)#hostname R1

4. 退出到特权模式
R1(config)#end

5.退出到用户模式
R1#disable

6.退出控制台线路
R1>quit

7.通过console进入控制台口线路
R1(config)#line console {number}

8.启动光标跟随
R1(config-line)#logging synchronous

9.设置键盘多久无动作，自动被弹出到用户模式以外，即退出
（如果设置为0分0秒代表永不超时）

R1(config-line)#exec-timeout {minute}{second}

10.显示路由器的当前时间
R1#show clock

11.设置标语信息
R1(config)#banner login # {text} #    //这个banner配置一些登陆前的提示

R1(config)#banner motd  # {text} #   //这个banner配置一些成功登陆游的提示信息

12.进入接口配置模式
R1(config)#interface {type} {number}

13.为接口设置描述信息
R1(config-if)#description {text}

14.显示某个接口的配置信息
R1#show running-config interface {type}{number}

15. 设置特权模式进入密码
R1(config)#enable password {password}  //该密码是基于明文的(通过show running-config可见)

R1(config)#enable secret {password}    //  该密码是基于MD5加密的

注：密码是区分大小写的；如果同时设置了两种认证密码，只用后者生效

16.进入控制台口线路
R1(config)#line console {number}  //通过console线方式进入控制台

R1(config)#line aux {number}       //通过辅助接口（AUX）线路进入控制台

R1(config)#line vty {start-number}{end-number} //通过虚拟终端线路（VTY）进入控制台

注：虚拟终端线路（VTY）是为telnet会话所用

17.设置控制台端口的密码
R1(config-line)#password {password}  

注：这里的登录密码是明文方式保存在DRAM（running-config）文件中

R1(config-line)#login   //启动登陆

18.关闭DNS查询功能
R1(config)#no ip domain lookup

注：默认情况下，路由器的DNS查询是启用的，当输入一条Cisco IOS无法识别的命令时，路由器会把这个命令当成主机名，然后向DNS服务器进行查询。

19.ping测试
R1#ping {ip-address}

20.telnet测试
R1#telnet {ip-address}

注：在telnet到远端路由器的时候，如果对方的VTY线路没有设置密码和启动登陆，将拒绝本地路由器telnet。

解决方案：在远端路由器设置VTY线路的密码和启动登陆，如下配置：

R1(config)#line vty {start-num} {end-number} //进入VTY线路

R1(config-line)#password {password}    //设置密码

R1(config-line)#login  // 启动登陆

R1(config-line)#end  // 退出VTY线路

21.创建静态的IP地址到主机名的映射
R1(config)#ip host {hostname} {ip-address}

22.关闭CDP协议
R1(config)#no cdp run /*关闭CDP协议，不然会一直出现双工不匹配的提示*/

R3(config)#no cdp run /*以后的实验，只要涉及到以太网接口，就关闭CDP*/

 


重启路由器
1.重启路由器
R1#reload

2.计划性重启路由器
R1#reload [at {hh:mm day year} |in {minutes}][text]

注：可以定义路由器，立即重启或者在多少分钟后，或在具体的时间里重启，还可以制定重启原因。如果重启之前，路由器的配置文件被修改过，系统会提醒你是否保存修改。

3.查看重启信息
R1#show reload

接口设置
1进入接口配置模式
R1(config)#interface {type} {number}

2.为接口设置描述信息
R1(config-if)#description {text}

3.设置接口的IP地址信息
R1(config-if)#ip address {ip-address} {mask}

4.如果为串行接口，要为DCE端设置时钟频率
R1(config-if)#clock rate {speed}

5.开启接口
R2(config-if)#no shutdown

6.显示某个接口的配置信息
R1#show running-config interface {type}{number}

7.恢复接口配置到出厂模式
R1(config)#default interface {type} {number}

静态路由配置
1.配置静态路由
R1(config)#iproute {network} {mask} {next-hop-address|exit-interface} [distance]

         network：目标网络号

         mask：目标网络的子网掩码

         next-hop-address：下一跳地址

         exit-interfac：下一跳路由器的接口

注：选择下一跳地址和选择下一调路由器的接口作为目标网络的出口的区别在于管理距离。选择前者，管理距离为1；选择后者，管理距离为0。还可以在定义静态路由的时候指定管理距离。

2.配置默认路由
R1(config)#iproute 0.0.0.0  0.0.0.0 {next-hop-address|exit-interface}[distance]

         next-hop-address：下一跳地址

         exit-interfac：下一跳路由器的接口

注：0.0.0.0  0.0.0.0代表所有的网络。选择下一跳地址和选择下一调路由器的接口作为目标网络的出口的区别在于管理距离。选择前者，管理距离为1；选择后者，管理距离为0。还可以在定义静态路由的时候指定管理距离。

3.显示静态路由的配置
R1#showip route static

RIP（距离矢量路由协议）基本设置
配置RIP
1.启动RIP
R1(config)#routerip

2.定义要宣告的直连主类网络号
R1(config-route)#network{network-number}

注：启动了RIP路由协议之后，只需要宣告主类直连网络号，即可完成RIP的配置

3.查看RIP信息
R1#showip route rip

配置RIPv2
1.启动RIP
R1(config)#routerip

2.启动RIP版本2（RIPv2）
R1(config-route)#version2

3.定义要宣告的直连主类网络号
R1(config-route)#network{network-number}

注：启动了RIPv2路由协议之后，只需要宣告主类直连网络号，即可完成RIPv2的配置

4.查看RIP信息
R1#showip route rip

OSPF(链路状态路由协议)基本配置
配置单区域OSPF
1.启动OSPF进程：
R1(config)#routeospf {process-id}

注：OSPF进程ID可以使用1到65535中的任意一个整数，该ID只是本地的一个标识，即一个OSPF网络，每台OSPF路由器的进程ID是否一样，和OSPF网络能否正常运行无关。

2.定义参与OSPF进程的接口和网络
R1(config-route)#network{ip-address} {wildcard-mask} area {area-id}

         ip-address：直连网络地址

         wildcard-mask：直连网络的反掩码

         area-id：区域号

注：在定义OSPF路由器要宣告的区域时，反掩码用来控制要宣告的范围，0表示精确匹配，255表示任意匹配。OSPF网络中骨干区域为区域0，因此必须有区域0。

3.查看OSPF信息
R1#showip route ospf    // 查看所有的OSPF信息

R1#showip route ospf 1   //查看进程ID为1的OSPF信息

R1#showip ospf database   //查看OSPF链路状态数据库的信息

R1#showip ospf neighbor    //  显示一个邻居列表,

配置多区域OSPF
1.启动OSPF进程
R1`(config)#routeospf {process-id}

注：OSPF进程ID可以使用1到65535中的任意一个整数，该ID只是本地的一个标识，即一个OSPF网络，每台OSPF路由器的进程ID是否一样，和OSPF网络能否正常运行无关。

2.定义参与OSPF进程的接口和网络
R1(config-route)#network{ip-address} {wildcard-mask} area {area-id}

         ip-address：直连网络地址

         wildcard-mask：直连网络的反掩码

         area-id：区域号

注：在定义OSPF路由器要宣告的区域时，反掩码用来控制要宣告的范围，0表示精确匹配，255表示任意匹配。OSPF网络中骨干区域为区域0，因此必须有区域0。多区域的设计，才是OSPF网络的精髓。

3.查看OSPF信息
R1#showip route ospf    // 查看所有的OSPF信息

R1#showip route ospf 1   //查看进程ID为1的OSPF信息

R1#showip ospf database   //查看OSPF链路状态数据库的信息

R1#showip ospf neighbor    //  显示一个邻居列表,

EIGRP(混合型路由协议) 基本配置
配置EIGRP
1.定义自制系统（AS）号并启用EIGRP
R1(config)#routeeigrp {AS-number}

2.宣告直连主类网络号
R1(config-route)#network{network-number}

注：EIGRP做为IGRP的扩展，它同时集合了距离矢量和链路状态路由协议的特色，参与同一EIGRP进程的EIGRP路由器必须处于相同的AS里，接下来只需要宣告直连的主类网络号即可。

3.查看EIGRP信息
R1#showip eigrp neighbors

R1#showip route eigrp

关闭EIGRP的自动汇总
1.定义自制系统（AS）号并启用EIGRP
R1(config)#routeeigrp {AS-number}

2.宣告直连主类网络号
R1(config-route)#network{network-number}

注：EIGRP做为IGRP的扩展，它同时集合了距离矢量和链路状态路由协议的特色，参与同一EIGRP进程的EIGRP路由器必须处于相同的AS里，接下来只需要宣告直连的主类网络号即可。

3.关闭自动汇总
R1(config-route)#noauto-summary

注：当路由更新主类网络边界的时候，他会自动向主类网络号进行汇总，路由自动汇总特性是EIGRP默认的操作。EIGRP可以关闭该特性。

4.查看EIGRP信息
R1#showip eigrp neighbors

R1#showip route eigrp

交换机
基础配置
1.从用户模式进入特权模式
S1>enable

2.从特权模式进入全局配置模式
S1#configure terminal

3.设置主机名
 S1(config)#hostnameR1

4. 退出到特权模式
S1(config)#end

5.退出到用户模式
S1#disable

6.查看MAC地址表
S1#show mac-address-table

7.开启http服务（部分交换机可用）

S1(onfig)#ip http server

8.配置超级用户口令

S1(config)#enable password 123456 //不加密密码

S1(config)#enable password 7 123456 //加密密码（7是选择的加密方式）

S1(config)#enable secret 123456  //加密密码

S1(config)#enable secret 5 123456  //加密密码（5是选择的加密方式）

7.显示路由器的当前时间
R1#show clock

8.设置系统时间(部分可用)
S1(config)#clock set hh:mm:ss day month year

S1(config)#clock set 12:00:00 28 August 2013

9.配置设备管理IP地址
S1(config)#interface VLAN1

S1(config-if)#ip address 192.168.1.1255.255.255.0

S1(config-ip)#exit

注：VLAN 1是用于设备管理的默认VLAN

10.配置默认路由
S1(config)#ip default-gateway 192.168.1.254

VlAN的配置
常规配置
1.创建VLAN
S1(config)#vlan 100

2.给VLAN命名
S1(config-vlan)#name vlan100

3.删除VLAN
S1(config)#no vlan 100

进入VLAN数据库配置
1.进入VLAN数据库
S1#vlan database

2.创建VLAN
S1(vlan)#vlan 100 name vlan100

3.删除VLAN
S1(vlan)#no vlan 100

4.修改VLAN
S1(vlan)#vlan 100 name v100

分配端口到VLAN中
S1(config)#interface f0/1

S1(config-if)#switchport access vlan 100

VLAN TRAN的配置
S1(config)#interface f0/2

S1(config-if)#switchport mode trunk  //设置端口为trunk端口

S1(config-if)#switchport trunk allowed vlan100,2 //允许vlan 100和vlan 2通过

S1(config-if)# switchport trunk


```







# DHCP原理



![image-20230210165751605](http://cdn.gtrinee.top/image-20230210165751605.png)





![image-20230210165905361](http://cdn.gtrinee.top/image-20230210165905361.png)

DHCP：**动态主机设置协议（Dynamic Host Configuration Protocol**）是一个局域网的网络协议，使用 **UDP协议 工作**，主要有两个用途：用于内部网或网络服务供应商**自动分配IP地址**；给用户用于内部网管 理员作为对所有计**算 机作中央管理的手段。**

DHCP使用优点

-  减少管理员的工作量 
- 避免IP冲突 
- 提高IP地址的利用率 
- 移动计算机后不用重新配置网络信息，能够方便更改错误的可能性 
- DHCP用于给设备自动分配IP地址，我们几乎天天用到

DHCP相关概念

- DHCP客户端：获取网络配置参数 
- DHCP服务端：提供网络配置参数（IP地址，默认网关，租约相关信息等） 
- DHCP中继代理：服务端和客户端之间转发DHCP的设备（主机或者路由器） 
- 作用域：一个网络中的所有可分配IP地址的连续范围，主要用来定义物理子网的单一IP地址范围， 例如192.168.0.0-192.168.255.255 
- 超级作用域：一组作用域的集合，实现一个物理子网中多个逻辑IP地址。 
- 排除范围：排除作用域内有限的IP地址序列（不使用DHCP服务）192.168.0.100-192.168.0.200 
- 地址池：定义作用域+排除范围后，剩余的地址将形成可用地址池 
- 保留：DHCP服务器提供永久地址租约，确保客户端始终使用相同的IP地址 
- 租用：客户从服务器上获得并临时占用某IP地址的过程 
- 租约： **获得的IP地址的使用时间** 获得IP地址时租约被激活并更新其地址租约；当租约到期或者被删除时租约停止



## 总结

- 客户端会在租约时间过去 1/2的时候以**单播**方式请求续租 
- 在租约时间过去 7/8的时候以**广播**的方式请求续租 
- 在租约时间过去100%的时候，以广播方式重新发现局域网中的DHCP服务器

## DHCP地址绑定

- 通过上面的学习，我们知道设备必须提供自己的身份信息才能在dhcp服务端获取地址信息 
- 那么想要给设备绑定固定的IP地址，就必须知道设备的身份信息

![image-20220430224433373](http://cdn.gtrinee.top/image-20220430224433373.png)

#### 路由器配置

```bash
R1#conf t
R1(config)#int e0/0
R1(config-if)#ip add 192.168.1.1 255.255.255.0
R1(config-if)#no sh
R1(config-if)#ip dhcp pool cisco
R1(dhcp-config)#netw 192.168.1.0 /24
R1(dhcp-config)#def 192.168.1.1
R1(dhcp-config)#dns 114.114.114.114 114.114.115.115
R1(dhcp-config)#exit
R1(config)#ip dhcp ex 192.168.1.1
```

**windows绑定DHCP**

 查看windows获取到的IP地址

- 去路由器上查看分配这个地址的对应身份信息

```bash
R1#sh ip dhcp binding
Bindings from all pools not associated with VRF:
IP address Client-ID/ Lease expiration Type
Hardware address/
User name
192.168.1.3 010c.18a5.af90.00 Jun 18 2020 01:23 AM Automatic
```

可以看到windows使用的是 010c.18a5.af90.00 这个信息获得的这个IP地址，而这个信息并不是MAC 地址，这台windows的mac地址我们可以通过 ipconfig /all 查看





**Linux绑定DHCP**

- 步骤和windows一样，不过要注意linux是使用mac地址作为身份信息来获取DHCP的 
- 查看Linux获得的IP地址

![image-20220430224924117](http://cdn.gtrinee.top/image-20220430224924117.png)

- 在路由器上查看dhcp地址池，可以看到linux就是用mac地址来获得的DHCP信息

```bash
R1#show ip dhcp bin
Bindings from all pools not associated with VRF:
IP address Client-ID/ Lease expiration Type
Hardware address/
User name
192.168.1.2 0c18.a52c.fa00 Jun 18 2020 01:38 AM Automatic
```

- 绑定

```bash
R1#clear ip dhcp bin * # 别忘了先清空地址池
R1#conf t
R1(config)#ip dhcp pool linux
R1(dhcp-config)#host 192.168.1.101
R1(dhcp-config)#hardware-address 0c18.a52c.fa00 # 这次绑定的是硬件地址，也就是mac地址
```

![image-20220430225040962](http://cdn.gtrinee.top/image-20220430225040962.png)

# DNS域名系统

DNS(Domain Name System) 是一套从域名到IP的映射系统。 

在网络中要确定一台主机，可以通过IP地址来做到。但是IP地址不方便记忆， 于是人们发明了一种叫主 机名的东西 。 

最初时候人们把主机名和IP地址的对应关系都写在一个hosts文件里面，然后这个hosts文件由“互联网信 息中心（SRI-NIC）”来管理和分发。也就是人们需要定期更新hosts文件。这个文件目前在windows系统 的 C:\Windows\System32\drivers\etc\hosts 中。 

时间长了，这个Hosts的机制并不好用，而且更新不及时，主机名多了之后hosts文件太大了，后来就不 用这个机制了。 

人们后来改用域名解析系统DNS

- 一个组织的系统管理机构，维护系统内的每个主机的 IP和主机名 的对应关系 
- 如果新计算机接入网络，将这个信息注册到 数据库 中 
- 用户输入域名的时候，会自动查询 DNS 服务器，由 DNS服务器 检索数据库, 得到对应的IP地址。

## 域名

主域名是用来识别主机名称和主机所属的组织机构的一种分层结构的名称。 例如：http://www.baidu.com(域名使用.连接) www.baidu.com

- .：根域名 
- com： 一级域名，表示这是一个企业域名。同级的还有 "net"(网络提供商)，"org"(非盈利组织) 等。 
- baidu: 二级域名, 公司名。 
- www: 只是一种习惯用法，并不是每个域名都支持。 
- http:// : 要使用什么协议来连接这个主机名。

## 域名解析的过程

```bash
1. 浏览器缓存
2. 系统缓存,查找hosts文件
3. 路由器缓存————————以上三步均为DNS客户端的缓存！！
4. ISP DNS缓存
5. 根域名服务器
6. 顶级域名服务器
7. 主机名服务器
8. 保存结果至缓存

DNS查询类型
本地解析：过以前查询获得的缓存信息就地应答查询
递归查询：DNS服务器代表请求客户机联系其他DNS服务器，以完全解析，返回给客户机
迭代查询：客户机自己不断请求DNS服务来解析名称，典型的DNS服务器之间的交互
```

![这里写图片描述](https://img-blog.csdn.net/20180529191603529?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM3OTY0MDcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

**当你在浏览器输入www.baidu.com之后会发生什么？**

1. 浏览器发起域名解析，首先查询浏览器缓存，如果没有，就查询hosts文件，如果没有就提出域名 解析请求 

2. 客户机提出域名解析请求，并将该请求发送给**本地的域名服务器。** 
3.  当本地的域名服务器收到请求后,就**先查询本地的缓存**,如果有该纪录项,则**本地的域名服务器**就直接 把查询的结果返回。 
4.  如果本地的缓存中**没有该纪录**,则本地域名服务器就直接把**请求发给根域名服务器**,然后根域名服务 器再返回给本地域名服务器一个所查询域(根的子域)的主域名服务器的地址。 
5.  **本地服务器再向上一步返回的域名服务器发送请求**,然后接受请求的服务器查询自己的缓存,**如果没 有该纪录,则返回相关的下级的域名服务器的地址**。  
6. 重复第四步,直到找到正确的纪录。 
7. 本地域名服务器把返回的结果保存到缓存,以备下一次使用,同时还将结果返回给客户机

## 域名解析记录

```
A：记录地址，返回的域名所指向IP地址
NS：域名服务器，返回保存下一级域名信息的服务器地址。该记录只能设置为域名，不能设置为IP地址
MX：邮箱记录，返回接收电子邮箱的服务器地址
CNAME：规范名称记录，返回另一个域名，即当前查询的域名是另一个域名的跳转
PTR：逆查域名，只用于IP地址查询域名
dig -x
dig [a ns mx ] 查询指定的记录类型
扩展：
TXT：用来做SPF（反垃圾邮箱）
AAAA：用来指定主机名（或域名）对应的IPv6记录。
SRV：记录哪台计算机提供哪个服务。格式：服务
名字、点、协议的类型。
显性URL：从一个地址301重定向另一个地址的时候。 隐性URL：类似显性URL、区别在于隐形URL不会
改
变地址中的域名。
```

## 查看域名解析的工具

### nslookup 

windows上在 cmd 中直接输入使用

```
C:\Users\Lenovo>nslookup gtrinee.top
服务器:  public1.alidns.com
Address:  223.5.5.5

名称:    gtrinee.top


C:\Users\Lenovo>nslookup www.gtrinee.top
服务器:  public1.alidns.com
Address:  223.5.5.5

非权威应答:
名称:    www.gtrinee.top
Address:  81.68.240.170
```

### dig

dig（域信息搜索器）执行DNS搜索，显示从接受请求的域名服务器返回的答复。多数DNS管理员利用dig作为DNS问题的故障诊断，因为它灵活性好，易用、输出清晰。通常情况下dig使用命令行参数，但它也可以按批处理模式从文件读取搜索请求。不同于早期版本，dig的BIND9实现允许从命令行发出多个查询，除非被告知请求特定域名服务器，dig将尝试/etc/resolv.conf中列举的所有服务器。当未指定任何命令行参数或选项时，dig将对“.”执行NS查询。

```bash
[root@eagleslab ~]# dig iproute.cn

; <<>> DiG 9.11.4-P2-RedHat-9.11.4-9.P2.el7 <<>> iproute.cn
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 9577
;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
;; QUESTION SECTION:
;iproute.cn. IN A
;; ANSWER SECTION:
iproute.cn. 600 IN CNAME cqfz53.coding-pages.com.
cqfz53.coding-pages.com. 600 IN A 150.109.19.98
;; Query time: 84 msec
;; SERVER: 100.100.2.136#53(100.100.2.136)
;; WHEN: Fri Mar 13 19:18:33 CST 2020
;; MSG SIZE rcvd: 92

```



## cisco路由器配置DNS

```
ip dns server # 开启DNS服务器
ip host domain.com 192.168.1.1
```

![image-20220430231309702](http://cdn.gtrinee.top/image-20220430231309702.png)

- 代码步骤

```bash
# 第一步，配置ip地址，R1上记得配置一个环回接口地址1.1.1.1，略
# 第二步，在R1上配置dns并开启dns解析功能
R1(config)#ip dns server
R1(config)#ip host www.r3.com 192.168.13.3
R1(config)#ip name-server 1.1.1.1
R1(config)#ip domain lookup
# 第三步，在R2上指定dns服务器地址为1.1.1.1
R2(config)#ip name-server 1.1.1.1
R2(config)#ip domain lookup
# 第四步，在R2，R3上添加默认路由指向R1
R2(config)#ip route 0.0.0.0 0.0.0.0 192.168.12.1
R3(config)#ip route 0.0.0.0 0.0.0.0 192.168.13.1
# 第五步，验证
R2#ping www.r3.com
Translating "www.r3.com"...domain server (1.1.1.1) [OK]

Type escape sequence to abort.
Sending 5, 100-byte ICMP Echos to 192.168.13.3, timeout is 2 seconds:
!!!!!
Success rate is 100 percent (5/5), round-trip min/avg/max = 1/1/1 ms
```

## 实验

![image-20220430231638196](http://cdn.gtrinee.top/image-20220430231638196.png)



# NAT(Network Address Translation)

- 当今的互联网是由一个个小的自治系统组成，一个家庭，一个企业就是一个小的自治系统 
- 自治系统内部有着众多的设备需要IP地址联网，每个地址都需要去IANA申请明显做不到，所以就会 使用私有IP地址进行分配 
- 私有IP地址无法做到互联网通信，在内网之中就需要一个默认网关来代替大家请求互联网数据 
- NAT网络地址转换技术能够将数据包中的IP地址进行转换

## NAT优缺点

![image-20220501000734824](http://cdn.gtrinee.top/image-20220501000734824.png)

## 静态NAT

- 一对一映射，为每个内部的地址指定一个公网IP地址 
- 这种方法主要用在内网中存在需要对公网提供服务的服务器的场景，类似的例子有WEB服务器、邮 件服务器、FTP服务器等

![image-20220501001036375](http://cdn.gtrinee.top/image-20220501001036375.png)

- 地址配置

```bash
R1(config)#int e0/0
R1(config-if)#ip add 192.168.13.1 255.255.255.0
R1(config-if)#no sh
R1(config-if)#int e0/1
*Feb 1 07:53:24.935: %LINK-3-UPDOWN: Interface Ethernet0/0, changed state
to up
*Feb 1 07:53:25.946: %LINEPROTO-5-UPDOWN: Line protocol on Interface
Ethernet0/0, changed state to up
R1(config-if)#int e0/1
R1(config-if)#ip add 100.12.12.1 255.255.255.0
R1(config-if)#no sh
R1(config-if)#
*Feb 1 07:53:40.608: %LINK-3-UPDOWN: Interface Ethernet0/1, changed state
to up
*Feb 1 07:53:41.615: %LINEPROTO-5-UPDOWN: Line protocol on Interface
Ethernet0/1, changed state to up
R1(config-if)#
R2(config)#int e0/0
R2(config-if)#ip add 100.12.12.2 255.255.255.0
R2(config-if)#no sh
R2(config-if)#int lo0
R2(config-if)#ip add 2.2.2.2 255.255.255.0
R3(config)#int e0/0
R3(config-if)#ip add 192.168.13.3 255.255.255.0
R3(config-if)#no sh
```

- 在R1，R3上添加一条默认路由指向运营商

```
R1(config)#ip route 0.0.0.0 0.0.0.0 100.12.12.2
R3(config)#ip route 0.0.0.0 0.0.0.0 192.168.13.1
```

- 在R1 上做静态nat转换，我们找运营商获得一个全新的公网IP地址，假设是 100.12.12.3 ，然后将 其对应的分配给 `192.168.13.3` ，那么R3在上网的时候就可以用公网IP地址对外了

```bash
R1(config)#int e0/0
R1(config-if)#ip nat inside
R1(config-if)#int e0/1
R1(config-if)#ip nat outside
R1(config-if)#exit
R1(config)#ip nat inside source static 192.168.13.3 100.12.12.3
```

- 在r3上验证上外网

```bash
R3#ping 2.2.2.2
Type escape sequence to abort.
Sending 5, 100-byte ICMP Echos to 2.2.2.2, timeout is 2 seconds:
.!!!!
Success rate is 80 percent (4/5), round-trip min/avg/max = 1/1/2 ms

```

## PAT(端口地址转换)

- 正常情况下我们家用宽带，或者仅仅只是有上网需求的情况下，没必要为每个设备都申请一个公网 IP(也做不到) 
- 在数据通信的时候只是需要一个端口号用于接收和发送数据即可，而一个IP地址可以有65535个端 口号，所以将端口号轮流着分配给内网设备即可

![image-20220501002631938](http://cdn.gtrinee.top/image-20220501002631938.png)

- 配置ip地址

```bash
R1(config)#int e0/0
R1(config-if)#ip add 192.168.123.1 255.255.255.0
R1(config-if)#no sh
R1(config-if)#int e0/1
R1(config-if)#ip add
R1(config-if)#ip add 100.12.12.1 255.255.255.0
R1(config-if)#no sh
R2(config)#int e0/0
R2(config-if)#ip add 100.12.12.2 255.255.255.0
R2(config-if)#no sh
R2(config-if)#int lo0
R2(config-if)#ip add 2.2.2.2 255.255.255.0
R3(config)#int e0/0
R3(config-if)#ip add 192.168.123.3 255.255.255.0
R3(config-if)#no sh
R4(config)#int e0/0
R4(config-if)#ip add 192.168.123.4 255.255.255.0
R4(config-if)#no sh
```

- 给R1，R3，R4添加默认路由

```bash
R1(config)#ip route 0.0.0.0 0.0.0.0 100.12.12.2
R3(config)#ip route 0.0.0.0 0.0.0.0 192.168.123.1
R4(config)#ip route 0.0.0.0 0.0.0.0 192.168.123.1
```

- 在R1上进行配置pat

```bash
R1(config)#int e0/0
R1(config-if)#ip nat inside
R1(config-if)#int e0/1
R1(config-if)#ip nat outside
R1(config-if)#exit
R1(config)#access-list 1 permit 192.168.123.0 /24
R1(config)#ip nat inside source list 1 interface e0/1 overload
```

- 查看nat映射关系

```bash
R1#sh ip nat tr
Pro Inside global Inside local Outside local Outside global
icmp 100.12.12.1:0 192.168.123.3:0 2.2.2.2:0 2.2.2.2:0
icmp 100.12.12.1:1 192.168.123.4:0 2.2.2.2:0 2.2.2.2:1
```

## 端口映射 

- NAT会导致只能内网主动访问外网，而互联网没法主动访问内部网络，这样虽然保护了内部网络， 但是却丢失了端到端通信的过程 
- 端口映射可以将公网IP地址的端口对应到内网某个IP的端口号，从而让内网的设备也可以对外发布 服务 
- 端口映射可以让内网多个IP地址共用一个公网IP，可以节约很多成本

![image-20220501114850172](http://cdn.gtrinee.top/image-20220501114850172.png)

- 配置ip地址

```bash
R1(config)#int e0/0
R1(config-if)#ip add 192.168.12.1 255.255.255.0
R1(config-if)#no sh
R2(config)#int e0/0
R2(config-if)#ip add 192.168.12.2 255.255.255.0
R2(config-if)#no sh
R2(config-if)#int e0/1
R2(config-if)#ip add 100.23.23.2 255.255.255.0
R2(config-if)#no sh
R3(config)#int e0/0
R3(config-if)#ip add 100.23.23.3 255.255.255.0
R3(config-if)#no sh
```

- 在R1，R2上添加默认路由

```bash
R1(config)#ip route 0.0.0.0 0.0.0.0 192.168.12.2
R2(config)#ip route 0.0.0.0 0.0.0.0 100.23.23.3
```

- 做端口映射

```bash
R2(config)#int e0/0
R2(config-if)#ip nat inside
R2(config-if)#int e0/1
R2(config-if)#ip nat outside
R2(config-if)#ip nat inside source static tcp 192.168.12.1 23 interface
Ethernet0/1 23
```

- 开启R1的telnet服务

```bash
R1(config)# line vty 0 4
R1(config)# pass cisco
R1(config)# login
R1(config)# tran in telnet
```

- 在R3上尝试telnet公网地址

```bash
R3#telnet 100.23.23.2
Trying 100.23.23.2 ... Open

User Access Verification

Password:
R1>
```

- 查看一下端口映射关系

```bash
R2#sh ip nat tr
Pro Inside global Inside local Outside local Outside global
tcp 100.23.23.2:23 192.168.12.1:23 100.23.23.3:13107
100.23.23.3:13107
tcp 100.23.23.2:23 192.168.12.1:23 --- ---
```

## 负载均衡

- NAT也支持对公网IP地址的请求，分发给内部的设备来进行处理 
- R2 R3 R4是内网，内网的设备要求能访问外网 
- R1是外网，外网的设备能访问内网的服务

![image-20220501115606156](http://cdn.gtrinee.top/image-20220501115606156.png)

- 地址配置

```bash
R1(config)#int e0/0
R1(config-if)#ip add 100.12.12.1 255.255.255.0
R1(config-if)#no sh
R1(config-if)#int lo0
R1(config-if)#ip add 1.1.1.1 255.255.255.0
R2(config)#int e0/0
R2(config-if)#ip add 100.12.12.2 255.255.255.0
R2(config-if)#no sh
R2(config-if)#int e0/1
R2(config-if)#ip add 192.168.234.2 255.255.255.0
R2(config-if)#no sh
R3(config)#int e0/0
R3(config-if)#ip add 192.168.234.3 255.255.255.0
R3(config-if)#no sh
R4(config)#int e0/0
R4(config-if)#ip add 192.168.234.4 255.255.255.0
R4(config-if)#no sh
```

- 为R2，R3，R4添加网关

```bash
R2(config)#ip route 0.0.0.0 0.0.0.0 100.12.12.1
R3(config)#ip route 0.0.0.0 0.0.0.0 192.168.234.2
R4(config)#ip route 0.0.0.0 0.0.0.0 192.168.234.2
```

- 开启R3、R4telnet服务

```bash
R3(config)#line vty 0 4
R3(config-line)#pass cisco
R3(config-line)#login
R3(config-line)#tran in telnet
R4(config)#line vty 0 4
R4(config-line)#pass cisco
R4(config-line)#login
R4(config-line)#tran in telnet
```

- 通过nat做负载均衡

```bash
R2(config)#int e0/0
R2(config-if)#ip nat outside
R2(config-if)#int e0/1
R2(config-if)#ip nat inside
R2(config-if)#exit
R2(config)#access-list 2 permit 100.12.12.2
R2(config)#ip nat pool telnetservers 192.168.234.3 192.168.234.4 netmask
255.255.255.0 type rotary
R2(config)#ip nat inside destination list 2 pool telnetservers
```

- 在外网telnet R2的公网地址验证负载均衡是否成功

```bash
R1#telnet 100.12.12.2
Trying 100.12.12.2 ... Open
User Access Verification
Password:
R3>exit
[Connection to 100.12.12.2 closed by foreign host]
R1#telnet 100.12.12.2
Trying 100.12.12.2 ... Open
User Access Verification
Password:
R4>exit
[Connection to 100.12.12.2 closed by foreign host]
```

# 动态路由协议

- 通过在路由器上运行动态路由协议，使得路由器之间能够交互“用于路由计算的信息”，从而路由器 动态的“学习”到网络中的路由

## 管理距离 

- 不同的路由协议会有不同的管理距离 
- 值越小的管理距离优先级越高 
- 当路由器从不同的协议里学习到相同的路由的时候，优先选择优先级高的路由 
- 常见的管理距离

![image-20220501133931974](http://cdn.gtrinee.top/image-20220501133931974.png)

# 静态路由

- 特点 
- 需要通过手工的方式进行添加及维护； 
- 适用于组网规模较小的场景，如果网络规模较大，则配置及维护的成本就会很高； 
- 无法根据拓扑的变化进行动态的响应（各厂商开发了扩展特性，以便弥补静态路由在这点上的不 足）； 
- 在大型的网络中，往往采用动、静态路由结合的方式进行部署。 
- 配置方式

```bash
R1(config)# ip route network-address subnet-mask {ip-add | exit-interface}
```

![image-20220501134050192](http://cdn.gtrinee.top/image-20220501134050192.png)

## 环回接口

- Loopback接口，也叫环回口，是一个逻辑的、虚拟的接口； 
- 使用全局配置命令interface loopback 加上接口编号可创建一个Loopback接口，创建完成后即可 为接口配置IP地址； 
- Loopback接口在手工创建后，除非人为shutdown，否则不会DOWN掉； 
- Loopback接口常用于： 模拟路由器的直连网段，可用于测试； 
- 可用于设备管理（Loopback接口比较稳定）； 
- 供其他协议使用，例如OSPF、BGP、MPLS等； 
- SNMPTraps消息的源地址； 
- 其他用途（Loopback接口的用途十分广泛）。

## 缺省路由（默认路由）

```bash
ip route 0.0.0.0 0.0.0.0 [IP|INT] # 出接口的地址
```

# 动态路由协议，RIP

- RIP是应用及开发较早的路由协议，是典型的距离矢量路由协议 
- 适用于小型网络，最大跳数15跳（16跳视为不可达） 
- RIP是基于UDP的，使用端口号520 
- 在CISCO IOS平台上的管理距离为120

## 距离矢量路由协议

- 使用距离矢量路由协议的路由器并不了解网络的拓扑。
- 该路由器只知道： 
  - 自身与目的网络之间的距离 
  - 应该往哪个方向或使用哪个接口转发数据包 
  - 路由器收敛完成 
  - 当所有路由表包含相同网络可达性信息
  - 网络（路由）进入一个稳态 
  - 路由器继续交换路由信息 
  - 当无新路由信息被更新时收敛结束 
  - 网络在达到收敛前无法完全正常工作

## RIP解决环路问题的机制

- 定义最大跳数 
  - 定义当跳数达到16时认为不可达 
- 水平分割 
  - 从某个接口学习到的路由，不会再从这个接口更新出去 
- 毒性路由 
  - 当路由器感知到某个网段发生故障，可以立即泛洪该网段的路由（将其跳数设置为16跳，也 就是不可达），以此来快速刷新网络中其他路由器的路由表。 
- 毒性逆转 
  - 抑制计时器 
- 触发更新 
  - 拓扑发生变更时，路由器立即发送更新消息，而不等更新计时器超时

## RIP配置

```bash
Router(config)# router rip
Router(config-router)# version 1/2
Router(config-router)# network network-number
```

## RIP案例1

![image-20220501135359129](http://cdn.gtrinee.top/image-20220501135359129.png)

![image-20220501135653443](http://cdn.gtrinee.top/image-20220501135653443.png)

## RIPV2的路由汇总 

- 默认情况，rip version2 会将自己的路由条目进行汇总然后更新给其他路由器 
- 当路由汇总后出现同样的条目时，会进行等价的负载均衡 
- 如果想要进行人工汇总，建议首先关闭自动汇总，然后再进行手动汇总

```bash
R1(config)#router rip
R1(config-router)#version 2
R1(config-router)#no auto-summary # 关闭rip的自动路由汇总
R1(config-router)#int e0/0
R1(config-if)#ip summary-address rip 172.16.0.0 255.255.255.0 # 手动添加路由汇总
```

## OSPF实验拓扑

![image-20220501140205953](http://cdn.gtrinee.top/image-20220501140205953.png)



## 基础配置

```bash
# 配置ip地址，必须配环回接口
略
#配置ospf
方式一
R1(config)#router ospf 1
R1(config-router)#network 1.0.0.0 0.0.0.255 area 0
方式二
R2(config)#int range e0/0-1,lo0
R2(config-if-range)#ip ospf 1 area 0
```

# OSPF简介

- OSPF（Open Shortest Path First，开放最短路径优先）是一种**链路状态路由协议，无路由循环 （全局拓扑）**，属于IGP。RFC 2328，“开放”意味着非私有的，对公众开放的。 
- OSPF的报文封装 OSPF协议包直接封装于IP，协议号89。
- OSPF协议使用的组播地址 所有OSPF路由器——224.0.0.5；DR BDR——224.0.0.6 
- OSPF路由协议的管理距离：110

# 路由重发步概念

- 是可以将不同的自治系统他们之间的路由信息进行交换 
- 从一种协议到另外一种协议 
- 同一种协议的不同实例 
- 路由重发是针对外部的，自身的路由器不会有变化

### 拓扑

![image-20220501140803912](http://cdn.gtrinee.top/image-20220501140803912.png)

```bash
R2#sh ip route
		1.0.0.0/24 is subnetted, 1 subnets
R 1.1.1.0 [120/1] via 192.168.12.1, 00:00:15, Ethernet0/0
		2.0.0.0/8 is variably subnetted, 2 subnets, 2 masks
C 2.2.2.0/24 is directly connected, Loopback0
L 2.2.2.2/32 is directly connected, Loopback0
		3.0.0.0/32 is subnetted, 1 subnets
O 3.3.3.3 [110/11] via 192.168.23.3, 00:02:40, Ethernet0/1
		192.168.12.0/24 is variably subnetted, 2 subnets, 2 masks
C 192.168.12.0/24 is directly connected, Ethernet0/0
L 192.168.12.2/32 is directly connected, Ethernet0/0
		192.168.23.0/24 is variably subnetted, 2 subnets, 2 masks
C 192.168.23.0/24 is directly connected, Ethernet0/1
L 192.168.23.2/32 is directly connected, Ethernet0/1


R1#sh ip route
		1.0.0.0/8 is variably subnetted, 2 subnets, 2 masks
C 1.1.1.0/24 is directly connected, Loopback0
L 1.1.1.1/32 is directly connected, Loopback0
		192.168.12.0/24 is variably subnetted, 2 subnets, 2 masks
C 192.168.12.0/24 is directly connected, Ethernet0/0
L 192.168.12.1/32 is directly connected, Ethernet0/0


R3#sh ip route
		2.0.0.0/32 is subnetted, 1 subnets
O 2.2.2.2 [110/11] via 192.168.23.2, 00:00:12, Ethernet0/0
		3.0.0.0/8 is variably subnetted, 2 subnets, 2 masks
C 3.3.3.0/24 is directly connected, Loopback0
L 3.3.3.3/32 is directly connected, Loopback0
		192.168.23.0/24 is variably subnetted, 2 subnets, 2 masks
C 192.168.23.0/24 is directly connected, Ethernet0/0
L 192.168.23.3/32 is directly connected, Ethernet0/0


#做双向重发布
R2(config-if-range)#router rip
R2(config-router)#ver 2
R2(config-router)#redistribute ospf 1 metric 5
R2(config-router)#router ospf 1
R2(config-router)#redistribute rip subnets


再次坚持路由表
R1#sh ip route
		1.0.0.0/8 is variably subnetted, 2 subnets, 2 masks
C 1.1.1.0/24 is directly connected, Loopback0
L 1.1.1.1/32 is directly connected, Loopback0
		2.0.0.0/24 is subnetted, 1 subnets
R 2.2.2.0 [120/5] via 192.168.12.2, 00:00:28, Ethernet0/0
		3.0.0.0/32 is subnetted, 1 subnets
R 3.3.3.3 [120/5] via 192.168.12.2, 00:00:28, Ethernet0/0
		192.168.12.0/24 is variably subnetted, 2 subnets, 2 masks
C 192.168.12.0/24 is directly connected, Ethernet0/0
L 192.168.12.1/32 is directly connected, Ethernet0/0
R 192.168.23.0/24 [120/5] via 192.168.12.2, 00:00:28, Ethernet0/0
```

# OSPF三张表

![image-20220501141946708](http://cdn.gtrinee.top/image-20220501141946708.png)



```bash
R2#show ip ospf nei
Neighbor ID Pri State Dead Time Address Interface
3.3.3.3 1 FULL/DR 00:00:31 192.168.23.3 Ethernet0/1
1.1.1.1 1 FULL/BDR 00:00:39 192.168.12.1 Ethernet0/0
```

## OSPF名词

- Neighbor ID：邻居的id，这个id通常是由环回接口选的，并且是优先选取地址大的作为id 
  - 在一个OSPF域中，唯一地标识一台OSPF路由器 
  - 32bits，表现为IPv4地址形式。在未有手工指定的情况下，如果本地有激活的Loopback接 口，则取Loopback接口IP最大值；如果没有LP接口，则取激活的物理接口IP中的最大值 
  - 为了提高路由器的RID的稳定性和网络的稳定性建议手动的设置路由器的Router-ID：在OSPF 的进程下修改:router-id （建议id值以编号为准） 
  - 项目实施中，一般是建立loopback口，并且手工指定loopback口地址为router-id

- Pri：优先级 
- Dead Time：死亡时间，每十秒钟会更新一次，如果40秒倒计时结束还没有收到邻居的hello包， 认为邻居死亡
- State：邻居的状态 
  - DR 
    - DR的作用：多路访问中为了减少邻接关系（N平方的问题）和LSA的洪泛，采用DR机 制,BDR提供了备份 
    - MA网络上的所有路由器均与DR、BDR建立邻居关系
  - BDR 
    - 选举规则
    - 接口优先级数字越大越优先（优先级为0不能参与DR的选举） 
    - Router ID越大越好 
    - 稳定压倒一切（非抢占） 
    - 通过控制接口优先级是控制DR选举的好办法 
    - DR的选举是基于接口的，如果说某个路由器是DR，这种说法是错误的

![image-20220501213828890](http://cdn.gtrinee.top/image-20220501213828890.png)



- 在某些以太网中并不需要建立DR、BDR的过程，可以将模式修改为point-to-point来加速邻居 建立的过程

```bash
R2(config)#int e0/0
R2(config-if)#ip ospf network point-to-point
R1#sh ip ospf neighbor
Neighbor ID Pri State Dead Time Address Interface
2.2.2.2 0 FULL/ - 00:00:32 192.168.12.2 Ethernet0/0
# 状态中是没有DR或者BDR的
```



- OSPF COST

  - OSPF接口COST＝参考带宽（10的8次方，单位为b）/ 接口带宽 
  - 接口带宽为接口逻辑带宽，可以使用bandwith命令调整（这里默认单位为kb），主要用于路 由计算，而不是接口物理带宽，但一般情况：接口逻辑带宽＝接口物理带宽。 
  - 手工修改接口Cost的方法 
  - Router(config)# int e0/0 
  - Router(config-if)# ip ospf cost 100 !! 该命令在接收路由的入口上配置，也就是数据流量的出 口 
  - 可修改“参考带宽”,来保障OSPF在现如今的网络中正常运转
    - 建议将参考带宽设置为整个网络中的最大带宽 
    - auto-cost reference-bandwidth <参考带宽以Mbits为单位>

  

## 邻居建立过程

**状态**

- Down
  - 路由器未开始运行OSPF 
- Init 
  - 路由器收到对方发过来的hello，但是却没有发现存在自己的Router-Id

- Two-way 
  - 路由器收到对方发过来的hello中，是包含有自己的Router-ID 
  - 表示双方已经正常通信 
  - 如果是广播网络类型，在这个阶段会等待40s种，等所有路由器的Hello都充分交换，然后选 择Router-id最大的作为DR，过时不候。

- Ex-Start 
  - 路由器发送空的DBD数据报文，用来选举由谁来主导整个过程，最终是选择Router-id较大的 
  - L置位表示是否完成选举过程，M置位表示是否是最后一条消息，MS置位表示的是否是 MASTER

- Exchange 
  - 路由器交换互相的DBD，可以理解为目录，从的节点率先发送给主节点 
  - 比对哪些LSA是自己没有的

- Loading 
  - 向对方发送请求的LSA，接受对方的LSA，可以理解为书的内容 
  - 并且回复ACK

- Full 
  - 完成j建立过程

## OSPF消息类型

- hello包 用来建立以及维护邻居关系的数据包 
- DBD 链路状态数据库描述信息 
- LSR 链路状态请求，向邻居请求自己没有的信息 
- LSU 链路状态更新的信息，可以包含一条或者多条 
- ACK 确认消息，表示收到了

## OSPF多区域

### 单区域的问题 

- 收到的LSA通告太多了，OSPF路由器的负担很大 
- 内部动荡会引起全网路由器的完全SPF计算 
- 资源消耗过多，LSDB庞大，设备性能下降，影响数据转发 
- 每台路由器都需要维护的路由表越来越大，单区域内路由无法汇总

### 多区域的特点

- 减少了LSA洪泛的范围，有效地把拓扑变化控制在区域内，达到网络优化的目的 
- 在区域边界可以做路由汇总，减小了路由表 
- 充分利用OSPF特殊区域的特性，进一步减少LSA泛洪，从而优化路由

- 多区域提高了网络的扩展性，有利于组建大规模的网络

## 区域 

- 骨干区域，编号为0的区域 
- 非骨干区域，编号非0的区域 
- 所有非骨干区域必须和骨干区域相连

## OSPF路由器角色

![image-20220501225850667](http://cdn.gtrinee.top/image-20220501225850667.png)

- ABR 
  - 区域边界路由器，负责各个区域的路由条目传递 
  - 必须至少有一个接口和骨干区域相连 
  - 必须至少有一个接口和非骨干区域相连 
- ASBR 
  - AS边界路由器，负责将ospf以外的路由引入

## 多区域基本拓扑

![image-20220501230014688](http://cdn.gtrinee.top/image-20220501230014688.png)

- 相关命令

```bash
show ip ospf
显示OSPF路由器ID，OSPF定时器以及LSA信息
show ip ospf interface type
显示各种定时器和邻接关系
show ip route ospf
显示路由器学习到的OSPF路由
show ip protocols
显示IP路由协议参数
debug ip ospf events
显示OSPF相关事件
debug ip ospf adj
跟踪邻接关系的建立和终止
debug ip ospf packet
查看正在传输的OSPF分组
```

- 当非骨干区域没有和骨干区域直接相连，无法学习到其他区域的路由，如何解决这个问题

![image-20220501230127096](http://cdn.gtrinee.top/image-20220501230127096.png)

- 第一种方式是使用虚链路

```bash
R3(config)#router ospf 1
R3(config-router)#area 2 virtual-link 4.4.4.4
R4(config)#router ospf 1
R4(config-router)#area 2 virtual-link 3.3.3.3
```

- 第二种方式是使用隧道

```bash
# 第一种方式，R3和R4上同时都需要配置以下相同的配置，以完成虚链路
R3(config)#router ospf 1
R3(config-router)#area 2 virtual-link 4.4.4.4
# 第二种方式
R3#sh run
interface Tunnel0
ip address 192.168.100.3 255.255.255.0
ip ospf 1 area 0
tunnel source Ethernet0/1
tunnel mode ipip
tunnel destination 192.168.34.4
```

# 什么是LSA

- LSA（**链路状态广播）是链接状态协议使用的一个分组**，它包括有关邻居和通道成本的信息。 LSA 被路由器接收用于维护它们的路由选择表。 LSA: Link-State Advertisement。

![image-20220502000426555](http://cdn.gtrinee.top/image-20220502000426555.png)

## LSA类型有哪些

![image-20220502140941477](http://cdn.gtrinee.top/image-20220502140941477.png)

## 1类LSA

-  每个路由器针对它所在的区域产生LSA1，描述**区域内部与路由器直连的链路的信息（包括链路类 型，Cost等） ；**
-  LSA1只允许在本区域内洪泛，不允许跨越ABR； 
- LSA中会标识路由器是否是ABR(B比特置位),ASBR（E比特置位）或者是Virtual-link（V比特置位） 的端点的身份信息；

```bash
R1#sh ip ospf database
		OSPF Router with ID (1.1.1.1) (Process ID 1)
	Router Link States (Area 0)
Link ID ADV Router Age Seq# Checksum Link count
1.1.1.1 1.1.1.1 88 0x80000005 0x006F8C 3
2.2.2.2 2.2.2.2 89 0x80000006 0x000BE6 3

```

- Link ID：链路ID，可以理解为目的地 
- ADV Router：链路来自哪一个路由器 
- Age：是计时器 
- Seq：序列号，初始值为 0x80000001，每收到一次数据包更新一次这个数值会+1， 加到0x8fffffff 达到最大，下一次变为 0x80000000，ospf认为0x80000000是不可用的 
- Checksum：校验和

## 2类LSA 

- 描述TransNet（包括Broadcast和NBMA网络）网络信息； 
- **由DR生成**，描述其在该网络上连接的所有路由器以及网段掩码信息，以及这个MA所属的路由器； 
- LSA类型2只在本区域Area内洪泛，不允许跨越ABR； 
- Network LSA ID是DR进行宣告的那个接口的IP地址 
- Network LSA 中没有COST字段

```bash
R1#sh ip ospf database network
    	OSPF Router with ID (1.1.1.1) (Process ID 1)
    Net Link States (Area 0)
LS age: 148
Options: (No TOS-capability, DC)
LS Type: Network Links
Link State ID: 192.168.12.3 (address of Designated Router)
Advertising Router: 3.3.3.3
LS Seq Number: 80000002
Checksum: 0x1484
Length: 36
Network Mask: /24
    Attached Router: 3.3.3.3
    Attached Router: 1.1.1.1
    Attached Router: 2.2.2.2

```

- 通过LSA1，LSA2在区域内洪泛,使区域内每个路由器的LSDB达到同步，计算生成标识为“O”的路 由，解决区域内部的通信问题。

## 3类LSA 

- 由ABR生成，实际上这就就是将**区域内部的Type1 Type2的信息收集起来以路由子网的形式扩散出** 去,是Summay LSA中Summay的含义（注意这里的summary与路由汇总没有关系） 
- Type 3 的**链路状态ID是目的网络地址。** 
- 如果—台ABR路由器在与它本身相连的区域内有多条路由可以到达目的地,那么它将只会始发单一的 一条网络汇总LSA到骨干区域,而且这条网络汇总LSA是上述多条路由中代价最低的。 
- ABR收到来自同区域其它ABR传来的Type 3 LSA后重新生成新的Type3 LSA（Advertising Router改 为自己）然后继续在整个OSPF系统内扩散

```bash
R1#show ip ospf database summary
    	OSPF Router with ID (1.1.1.1) (Process ID 1)
    Summary Net Link States (Area 0)
LS age: 145
Options: (No TOS-capability, DC, Upward)
LS Type: Summary Links(Network)
Link State ID: 5.5.5.5 (summary Network Number)
Advertising Router: 2.2.2.2
LS Seq Number: 80000001
Checksum: 0xD441
Length: 28
Network Mask: /32
MTID: 0 Metric: 11
LS age: 186
Options: (No TOS-capability, DC, Upward)
LS Type: Summary Links(Network)
Link State ID: 192.168.25.0 (summary Network Number)
Advertising Router: 2.2.2.2
LS Seq Number: 80000001
Checksum: 0xEBBC
Length: 28
Network Mask: /24
	MTID: 0 Metric: 10
```

## 4类LSA

- ASBR Summary LSA由ABR生成，用于描述ABR能够到达的ASBR它的链路状态，链路状态ID为目 的ASBR的RID。

```bash
R5#sh ip ospf database asbr-summary
    	OSPF Router with ID (5.5.5.5) (Process ID 1)
    Summary ASB Link States (Area 1)
LS age: 318
Options: (No TOS-capability, DC, Upward)
LS Type: Summary Links(AS Boundary Router)
Link State ID: 1.1.1.1 (AS Boundary Router address)
Advertising Router: 2.2.2.2
LS Seq Number: 80000001
Checksum: 0x75B0
Length: 28
Network Mask: /0
	MTID: 0 Metric: 10
```

## 5类LSA

- Autonomous System External LSA由ASBR生成用于描述OSPF自治域系统外的目标网段信息，链 路状态ID是目的地址的IP网络号。 
- 外部路由通过重发布，引入OSPF路由域，相应信息(路由条目)由ASBR以LSA5的形式生成然后进入 OSPF路由域 
- OE2 开销= 外部开销； 
- OE1 开销= 外部开销+ 内部开销；

```bash
R5#sh ip ospf database external
    	OSPF Router with ID (5.5.5.5) (Process ID 1)
    Type-5 AS External Link States
LS age: 71
Options: (No TOS-capability, DC, Upward)
LS Type: AS External Link
Link State ID: 0.0.0.0 (External Network Number )
Advertising Router: 1.1.1.1
LS Seq Number: 80000002
Checksum: 0xA9E8
Length: 36
Network Mask: /0
    Metric Type: 1 (Comparable directly to link state metric)
    MTID: 0
    Metric: 666
    Forward Address: 0.0.0.0
    External Route Tag: 1
```

四类和五类的理解 

- 四类LSA告诉你怎么到达ASBR，由ABR产生 
- 五类LSA告诉你具体外部有哪些路由可以走，由ASBR产生

## 7类LSA 

- NSSA中的外部LSA NSSA 
- External LSA 在NSSA(非完全存根区域)not-so-stubby area中ASBR针对外部网络产生类似于LSA5的LSA类型7, 
- 链路ID是外部网路地址
- LSA类型7只能在NSSA区域中洪泛，到达NSSA区域ABR后，NSSA ABR将其转换成LSA类型5外部路 由，传播到Area 0，从而传播到整个OSPF路由域 
- 生成路由缺省用ON2表示，也可指定为ON1；

```bash
R2#sh ip ospf database nssa-external
   	 	OSPF Router with ID (2.2.2.2) (Process ID 1)
    Type-7 AS External Link States (Area 1)
LS age: 493
Options: (No TOS-capability, Type 7/5 translation, DC, Upward)
LS Type: AS External Link
Link State ID: 100.100.100.0 (External Network Number )
Advertising Router: 1.1.1.1
LS Seq Number: 80000002
Checksum: 0x4719
Length: 36
Network Mask: /24
    Metric Type: 2 (Larger than any link state path)
    MTID: 0
    Metric: 20
    Forward Address: 1.1.1.1
    External Route Tag: 0
```

# 交换机的三种端口类型

**一 端口类型**

1 [Access](http://www.chinabyte.com/keyword/access/)用户模式

2 Trunk链路模式

3 Hybrid模式（跟Trunk很类似但比trunk高级）

**二 端口介绍**

2.1 Access类型端口：

**只允许默认vlan的以太网帧**，也就是说只能属于一个vlan，Access端口在收到以太网帧后打上vlan标签，转发时在剥离vlan标签，一般情况下一端连接的是计算机。

2.2 Trunk类型端口：

　　可以允许多个vlan通过，可以接受并转发多个vlan的报文一般作用于交换机之间连接的端口，在网络的分层结构方面，**trunk被解释为"端口聚合"**，就是把多个物理端口捆绑在一起作为一个逻辑端口使用，作用可以扩展带宽和做链路的备份。

2.3 Hybrid类型端口：

　　Hybrid类型的端口跟trunk类型的端口很相似，**也是可以允许多个vlan通过，可以接受和发送多个vlan的报文**，可以作用于交换机之间，也可以作用于连接用户的计算机端口上，**跟trunk端口不同的是，Hybrid端口可以允许多个vlan发送时不打标签，而trunk端口只允许缺省vlan的报文发送时不打标签。**

**三 处理过程**

**3.1接收报文时的处理：**

​	Access端口：收到一个报文，**判断是否有VLAN信息：如果没有则打上端口的缺省VLAN**，并进行交换转发,如果有则直接丢弃.

trunk端口：收到一个报文，判断是否有VLAN信息：如果没有则打上端口的缺省VLAN，并进行交换转发，如果**有判断该trunk端口是否允许该 VLAN的数据进入**：如果可以则转发，否则丢弃

hybrid端口：收到一个报文，判断是否有VLAN信息：如果没有则打上端口的缺省VLAN，并进行交换转发；如果有，**判断该hybrid端口是否允许该VLAN的数据进入**，如果可以则转发，否则丢弃

3.2发报文：

Access端口：将报文的VLAN信息剥离，直接发送出去。

trunk端口：比较端口的缺省VLAN和将要发送报文的VLAN信息，如果两者相等则剥离VLAN信息再发送，如果不相等则直接发送该报文。

hybrid端口：判断该VLAN在本端口的属性（disp interface 即可看到该端口对哪些VLAN是untag， 哪些VLAN是tag）。如果是untag则剥离VLAN信息再发送，如果是tag则直接发送。


# 特殊区域

##  拓扑

![image-20220502142518127](http://cdn.gtrinee.top/image-20220502142518127.png)

## stub area

- 随着大量的5类LSA进入ospf区域，OSPF Database会变得庞大，同时路由表的外部地址也会增 大。这会占用路由器大量的资源。 
- 解决这个问题的办法是：让Area内部的路由器不记录任何AS外部的地址，而使用ABR作为默认网 关，有一条指向ABR的默认路由。 这种方式我们把它叫做stub area。 
- 配置 
- router ospf 2 
- area 1 stub 
- 在区域二里涉及到的所有路由器使用上述命令 
- 没有配置末梢节点之前的路由表

```bash
R6#sh ip route
O*E2 0.0.0.0/0 [110/1] via 192.168.46.4, 00:00:03, Ethernet0/0
1.0.0.0/32 is subnetted, 1 subnets
O IA 1.1.1.1 [110/31] via 192.168.46.4, 00:08:01, Ethernet0/0
2.0.0.0/32 is subnetted, 1 subnets
O IA 2.2.2.2 [110/31] via 192.168.46.4, 00:08:01, Ethernet0/0
3.0.0.0/32 is subnetted, 1 subnets
O IA 3.3.3.3 [110/21] via 192.168.46.4, 00:08:01, Ethernet0/0
4.0.0.0/32 is subnetted, 1 subnets
O IA 4.4.4.4 [110/11] via 192.168.46.4, 00:08:01, Ethernet0/0
5.0.0.0/32 is subnetted, 1 subnets
O 5.5.5.5 [110/21] via 192.168.46.4, 00:08:01, Ethernet0/0
6.0.0.0/8 is variably subnetted, 2 subnets, 2 masks
C 6.6.6.0/24 is directly connected, Loopback0
L 6.6.6.6/32 is directly connected, Loopback0
O IA 192.168.13.0/24 [110/30] via 192.168.46.4, 00:08:01, Ethernet0/0
O IA 192.168.23.0/24 [110/30] via 192.168.46.4, 00:08:01, Ethernet0/0
O IA 192.168.34.0/24 [110/20] via 192.168.46.4, 00:08:01, Ethernet0/0
O 192.168.45.0/24 [110/20] via 192.168.46.4, 00:08:01, Ethernet0/0
192.168.46.0/24 is variably subnetted, 2 subnets, 2 masks
C 192.168.46.0/24 is directly connected, Ethernet0/0
L 192.168.46.6/32 is directly connected, Ethernet0/0

```

- 配置了末梢节点之后的路由表

```bash
R6#sh ip route
O*IA 0.0.0.0/0 [110/11] via 192.168.46.4, 00:00:14, Ethernet0/0
1.0.0.0/32 is subnetted, 1 subnets
O IA 1.1.1.1 [110/31] via 192.168.46.4, 00:00:24, Ethernet0/0
2.0.0.0/32 is subnetted, 1 subnets
O IA 2.2.2.2 [110/31] via 192.168.46.4, 00:00:24, Ethernet0/0
3.0.0.0/32 is subnetted, 1 subnets
O IA 3.3.3.3 [110/21] via 192.168.46.4, 00:00:24, Ethernet0/0
4.0.0.0/32 is subnetted, 1 subnets
O IA 4.4.4.4 [110/11] via 192.168.46.4, 00:00:24, Ethernet0/0
5.0.0.0/32 is subnetted, 1 subnets
O 5.5.5.5 [110/21] via 192.168.46.4, 00:00:24, Ethernet0/0
6.0.0.0/8 is variably subnetted, 2 subnets, 2 masks
C 6.6.6.0/24 is directly connected, Loopback0
L 6.6.6.6/32 is directly connected, Loopback0
O IA 192.168.13.0/24 [110/30] via 192.168.46.4, 00:00:24, Ethernet0/0
O IA 192.168.23.0/24 [110/30] via 192.168.46.4, 00:00:24, Ethernet0/0
O IA 192.168.34.0/24 [110/20] via 192.168.46.4, 00:00:24, Ethernet0/0
O 192.168.45.0/24 [110/20] via 192.168.46.4, 00:00:24, Ethernet0/0
192.168.46.0/24 is variably subnetted, 2 subnets, 2 masks
C 192.168.46.0/24 is directly connected, Ethernet0/0
L 192.168.46.6/32 is directly connected, Ethernet0/0
R6#
```

