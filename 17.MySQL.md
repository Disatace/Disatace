# MySQL

## 前言

金三银四很快就要来啦，准备了索引的15连问，相信大家看完肯定会有帮助的。

![图片](https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpwSP2IkzhZw4BticmiaDmFnicdgXSeo8CAyiblD0tznKPPIZDJpGNwVS59hXjiacQhGoKALSS4VIZ23icuA/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1)

## 1. 索引是什么？

![图片](https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpwSP2IkzhZw4BticmiaDmFnicd4oCJXicPAIOPT3giaGN9gmT7xB2ObdSfoh6ic0Fzn1RNLEebbDUcoqz2Q/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1)

- 索引是一种能提高数据库查询效率的数据结构。它可以比作一本字典的目录，可以帮你快速找到对应的记录。
- 索引一般存储在磁盘的文件中，它是占用物理空间的。
- 正所谓水能载舟，也能覆舟。适当的索引能提高查询效率，过多的索引会影响数据库表的插入和更新功能。

## 2. MySQL索引有哪些类型

![图片](https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpwSP2IkzhZw4BticmiaDmFnicd0aEqEPUqzNtdpS0Shy5BPORuiaCtox9F0wh7tex6X0WnLKJR0gbvKbQ/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1)

**数据结构维度**

- B+树索引：所有数据存储在叶子节点，复杂度为`O(logn)`，适合范围查询。
- 哈希索引:  适合等值查询，检索效率高，一次到位。
- 全文索引：`MyISAM`和`InnoDB`中都支持使用全文索引，一般在文本类型`char,text,varchar`类型上创建。
- `R-Tree`索引: 用来对`GIS`数据类型创建`SPATIAL`索引

**物理存储维度**

- 聚集索引：聚集索引就是以主键创建的索引，在叶子节点存储的是表中的数据。（`Innodb`存储引擎）
- 非聚集索引：非聚集索引就是以非主键创建的索引，在叶子节点存储的是主键和索引列。（`Innodb`存储引擎）

**逻辑维度**

- 主键索引：一种特殊的唯一索引，不允许有空值。
- 普通索引：`MySQL中`基本索引类型，允许空值和重复值。
- 联合索引：多个字段创建的索引，使用时遵循最左前缀原则。
- 唯一索引：索引列中的值必须是唯一的，但是允许为空值。
- 空间索引：`MySQL5.7`之后支持空间索引，在空间索引这方面遵循`OpenGIS`几何数据模型规则。

## 3. 索引什么时候会失效？

- 查询条件包含`or`，可能导致索引失效
- 如果字段类型是字符串，`where`时一定用引号括起来，否则索引失效
- `like`通配符可能导致索引失效。
- 联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。
- 在索引列上使用 mysql 的内置函数，索引失效。
- 对索引列运算（如，`+、-、*、/`），索引失效。
- 索引字段上使用`（！= 或者 < >，not in）`时，可能会导致索引失效。
- 索引字段上使用`is null， is not null`，可能导致索引失效。
- 左连接查询或者右连接查询查询关联的字段编码格式不一样，可能导致索引失效。
- mysql 估计使用全表扫描要比使用索引快,则不使用索引。

## 4. 哪些场景不适合建立索引？

- 数据量少的表，不适合加索引
- 更新比较频繁的也不适合加索引
- 区分度低的字段不适合加索引（如性别）
- `where、group by、order by`等后面没有使用到的字段，不需要建立索引
- 已经有冗余的索引的情况（比如已经有`a,b`的联合索引，不需要再单独建立`a`索引）

## 5. 为什么要用 B+树，为什么不用二叉树？

> 可以从几个维度去看这个问题，查询是否够快，效率是否稳定，存储数据多少， 以及查找磁盘次数，为什么不是二叉树，为什么不是平衡二叉树，为什么不是 B 树，而偏偏是 B+树呢？

**为什么不是一般二叉树？**

如果二叉树特殊化为一个链表，相当于全表扫描。平衡二叉树相比于二叉查找 树来说，查找效率更稳定，总体的查找速度也更快。

**为什么不是平衡二叉树呢？**

我们知道，在内存比在磁盘的数据，查询效率快得多。如果树这种数据结构作 为索引，那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说 的一个磁盘块，但是平衡二叉树可是每个节点只存储一个键值和数据的，如果 是 B 树，可以存储更多的节点数据，树的高度也会降低，因此读取磁盘的次数 就降下来啦，查询效率就快啦。

**那为什么不是 B 树而是 B+树呢？**

- B+树非叶子节点上是不存储数据的，仅存储键值，而 B 树节点中不仅存储 键值，也会存储数据。innodb 中页的默认大小是 16KB，如果不存储数据，那 么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就 会更矮更胖，如此一来我们查找数据进行磁盘的 IO 次数有会再次减少，数据查 询的效率也会更快。 
- B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的，链 表连着的。那么 B+树使得范围查找，排序查找，分组查找以及去重查找变得 异常简单。

## 6. 一次B+树索引树查找过程

> 假设有以下表结构，并且初始化了这几条数据

```
CREATE TABLE `employee` (
  `id` int(11) NOT NULL,
  `name` varchar(255) DEFAULT NULL,
  `age` int(11) DEFAULT NULL,
  `date` datetime DEFAULT NULL,
  `sex` int(1) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx_age` (`age`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

insert into employee values(100,'小伦',43,'2021-01-20','0');
insert into employee values(200,'俊杰',48,'2021-01-21','0');
insert into employee values(300,'紫琪',36,'2020-01-21','1');
insert into employee values(400,'立红',32,'2020-01-21','0');
insert into employee values(500,'易迅',37,'2020-01-21','1');
insert into employee values(600,'小军',49,'2021-01-21','0');
insert into employee values(700,'小燕',28,'2021-01-21','1');
```

执行这条查询SQL，需要执行几次的树搜索操作？可以画下对应的索引树结构图~

```
select * from Temployee where age=32;
```

其实这个，这个大家可以先画出`idx_age`普通索引的索引结构图，大概如下：

![image-20230204215531184](http://cdn.gtrinee.top/image-20230204215531184.png)

再画出`id`主键索引，我们先画出聚族索引结构图，如下：

![image-20230204215549816](http://cdn.gtrinee.top/image-20230204215549816.png)

这条 SQL 查询语句执行大概流程是这样的：

- 搜索`idx_age` 索引树，将`磁盘块1`加载到内存，由于`32<43`,搜索左路分支，到磁盘寻址`磁盘块2`。
- 将`磁盘块2`加载到内存中，由于`32<36`,搜索左路分支，到磁盘寻址`磁盘块4`。
- 将`磁盘块4`加载到内存中，在内存继续遍历，找到`age=32`的记录，取得`id = 400`.
- 拿到`id=400`后，回到`id主键索引树`。
- 搜索`id主键索引树`，将`磁盘块1`加载到内存，因为`300<400<500`,所以在选择中间分支，到磁盘寻址`磁盘块3`。
- 虽然在`磁盘块3`，找到了id=400，但是它不是叶子节点，所以会继续往下找。到磁盘寻址`磁盘块8`。
- 将`磁盘块8`加载内存，在内存遍历，找到`id=400`的记录，拿到`R4`这一行的数据，好的，大功告成。

## 7. 什么是回表？如何减少回表？

当查询的数据在索引树中，找不到的时候，需要回到**主键索引树**中去获取，这个过程叫做**回表**。

比如在**第6**小节中，使用的查询SQL

```
select * from Temployee where age=32;
```

需要查询所有列的数据，`idx_age`普通索引不能满足，需要拿到主键id的值后，再回到`id`主键索引查找获取，这个过程就是回表。

## 8. 什么是覆盖索引？

如果我们查询SQL的`select *` 修改为 `select id, age`的话，其实是**不需要回表**的。因为`id`和`age`的值，都在`idx_age`索引树的叶子节点上，这就涉及到覆盖索引的知识点了。

> 覆盖索引是`select`的数据列只用从索引中就能够取得，不必回表，换句话说，查询列要被所建的索引覆盖。

## 9. 聊聊索引的最左前缀原则

索引的最左前缀原则，可以是**联合索引的最左N个字段**。比如你建立一个组合索引`（a,b,c）`，其实可以相当于建了`（a），（a,b）,(a,b,c)`三个索引，大大提高了索引复用能力。

当然，最左前缀也可以是**字符串索引的最左M个字符。**。比如，你的普通索引树是酱紫：

![image-20230204221116685](http://cdn.gtrinee.top/image-20230204221116685.png)

这个SQL:` select * from employee where name like '小%' order by age desc;` 也是命中索引的。

![image-20230204221132670](http://cdn.gtrinee.top/image-20230204221132670.png)

## 10. 索引下推了解过吗？什么是索引下推

给你这个SQL：

```
select * from employee where name like '小%' and age=28 and sex='0';
```

其中，`name`和`age`为联合索引（`idx_name_age`）。

如果是**Mysql5.6之前**，在`idx_name_age`索引树，找出所有名字第一个字是`“小”`的人，拿到它们的`主键id`，然后回表找出数据行，再去对比年龄和性别等其他字段。如图：

![图片](https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpwSP2IkzhZw4BticmiaDmFnicdHQ3zkfMOU0bsJ9d1ibOwCwS0289lcU7OcJQMVPnm96CjARgz0UBDdzQ/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1)

有些朋友可能觉得奇怪，`idx_name_age（name,age)`不是联合索引嘛？为什么选出包含`“小”`字后，不再顺便看下年龄`age`再回表呢，不是更高效嘛？所以呀，`MySQL 5.6`就引入了**索引下推优化**，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

因此，MySQL5.6版本之后，选出包含`“小”`字后，顺表过滤`age=28`

![图片](https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpwSP2IkzhZw4BticmiaDmFnicdZgnTbKsY4lMmLJWmYjUCJspFwl0kDbcicBeNiapYcUhSN7JOnmsIajLQ/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1)

## 11. 大表如何添加索引

如果一张表数据量级是千万级别以上的，那么，如何给这张表添加索引？

我们需要知道一点，**给表添加索引的时候**，**是会对表加锁的**。如果不谨慎操作，有可能出现生产事故的。可以参考以下方法：

1. 先创建一张跟原表`A`数据结构相同的新表`B`。
2. 在新表`B`添加需要加上的新索引。
3. 把原表`A`数据导到新表`B`
4. `rename`新表`B`为原表的表名`A`，原表`A`换别的表名；

## 12. 如何知道语句是否走索引查询？

`explain`查看SQL的执行计划，**这样就知道是否命中索引了**。

当`explain`与`SQL`一起使用时，MySQL将显示来自优化器的有关语句执行计划的信息。

![image-20230204224349445](http://cdn.gtrinee.top/image-20230204224349445.png)

一般来说，我们需要重点关注`type、rows、filtered、extra、key`。

### 1.2.1 type

type表示**连接类型**，查看索引执行情况的一个重要指标。以下性能从好到坏依次：`system > const > eq_ref > ref > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL`

- system：这种类型要求数据库表中只有一条数据，是`const`类型的一个特例，一般情况下是不会出现的。
- const：通过一次索引就能找到数据，一般用于主键或唯一索引作为条件，这类扫描效率极高，，速度非常快。
- eq_ref：常用于主键或唯一索引扫描，一般指使用主键的关联查询
- ref : 常用于非主键和唯一索引扫描。
- ref_or_null：这种连接类型类似于`ref`，区别在于`MySQL`会额外搜索包含`NULL`值的行
- index_merge：使用了索引合并优化方法，查询使用了两个以上的索引。
- unique_subquery：类似于`eq_ref`，条件用了`in`子查询
- index_subquery：区别于`unique_subquery`，用于非唯一索引，可以返回重复值。
- range：常用于范围查询，比如：between ... and 或 In 等操作
- index：全索引扫描
- ALL：全表扫描

### 1.2.2 rows

该列表示MySQL估算要找到我们所需的记录，需要读取的行数。对于InnoDB表，此数字是估计值，并非一定是个准确值。

### 1.2.3 filtered

该列是一个百分比的值，表里符合条件的记录数的百分比。简单点说，这个字段表示存储引擎返回的数据在经过过滤后，剩下满足条件的记录数量的比例。

### 1.2.4 extra

该字段包含有关MySQL如何解析查询的其他信息，它一般会出现这几个值：

- Using filesort：表示按文件排序，一般是在指定的排序和索引排序不一致的情况才会出现。一般见于order by语句
- Using index ：表示是否用了覆盖索引。
- Using temporary: 表示是否使用了临时表,性能特别差，需要重点优化。一般多见于group by语句，或者union语句。
- Using where : 表示使用了where条件过滤.
- Using index condition：MySQL5.6之后新增的索引下推。在存储引擎层进行数据过滤，而不是在服务层过滤，利用索引现有的数据减少回表的数据。

#### 1.2.5 key

该列表示**实际用到的索引**。一般配合`possible_keys`列一起看。

## 13.Hash 索引和 B+树区别是什么？你在设计索引是怎么抉择的？

- B+树可以进行范围查询，Hash 索引不能。
- B+树支持联合索引的最左侧原则，Hash 索引不支持。
- B+树支持 order by 排序，Hash 索引不支持。
- Hash 索引在等值查询上比 B+树效率更高。（但是索引列的重复值很多的话，Hash冲突，效率降低）。
- B+树使用 like 进行模糊查询的时候，like 后面（比如%开头）的话可以起到优化的作用，Hash 索引根本无法进行模糊查询。

## 14.  索引有哪些优缺点？

**优点：**

- 索引可以加快数据查询速度，减少查询时间
- 唯一索引可以保证数据库表中每一行的数据的唯一性

**缺点：**

- 创建索引和维护索引要耗费时间
- 索引需要占物理空间，除了数据表占用数据空间之外，每一个索引还要占用一定的物理空间
- 以表中的数据进行增、删、改的时候，索引也要动态的维护。

## 15. 聚簇索引与非聚簇索引的区别

聚簇索引并不是一种单独的索引类型，而是一种**数据存储方式**。它表示索引结构和数据一起存放的索引。非聚集索引是**索引结构和数据分开存放的索引**。

接下来，我们分不同存存储引擎去聊哈~

在`MySQL`的`InnoDB`存储引擎中， 聚簇索引与非聚簇索引最大的区别，在于叶节点是否存放一整行记录。聚簇索引叶子节点存储了一整行记录，而非聚簇索引叶子节点存储的是主键信息，**因此，一般非聚簇索引还需要回表查询。**

- 一个表中只能拥有一个聚集索引（因为一般聚簇索引就是**主键索引**），而非聚集索引一个表则可以存在多个。
- 一般来说，相对于非聚簇索引，聚簇索引查询效率更高，因为不用回表。

而在`MyISM`存储引擎中，它的主键索引，普通索引都是非聚簇索引，因为数据和索引是分开的，叶子节点都使用**一个地址指向真正的表数据**。









```bash
目录结构
MySQL安装部署
MySQL基础管理
MySQL体系结构
存储引擎原理
SQL语句使用
数据类型
索引管理
事务特性
日志管理
备份与恢复
主从复制原理
```

## 什么是数据

 数据(data)是事实或观察的结果，是对客观事物的逻辑归纳，是用于表示客观事物的未经加工的的原始 素材。 

数据可以是连续的值，比如声音、图像，称为模拟数据。也可以是离散的，如符号、文字，称为数字数 据。 在计算机系统中，数据以二进制信息单元0,1的形式表示。

 数据的定义:数据是指对客观事件进行记录并可以鉴别的符号，是对客观事物的性质、状态以及相互关系 等进行记载的物理符号或这些物理符号的组合。它是可识别的、抽象的符号。*

  

数据库管理系统种类

- RDBMS：以多张二维表的方式来存储，又给多张表建立了一定的关系 
- NoSQL：非关系型数据库

![image-20220416113555956](http://cdn.gtrinee.top/image-20220416113555956.png)



**特点对比**

 **关系型数据库（RDBMS）的**特点： 

二维表

 典型产品Oracle传统企业，MySQL互联网企业 

数据存取是通过SQL（Structured Query Language结构化查询语言）

 最大特点数据安全性方面强（ACID）

 **非关系型数据库（NoSQL：Not only SQL）**的特点：

 不是否定关系型数据库，而是做关系型数据库的补充



# MySQL安装部署

## 部署mariadb

```bash
[root@node1 ~]# yum install mariadb mariadb-server -y
```

- 初始化

```bash
[root@node1 ~]# systemctl start mariadb.service
[root@node1 ~]# mysql_secure_installation
Enter current password for root (enter for none): 当前root用户密码为空，所以直接
敲回车
OK, successfully used password, moving on...
Set root password? [Y/n] y 设置root密码
New password:
Re-enter new password:
Password updated successfully!
Remove anonymous users? [Y/n] y 删除匿名用户
... Success!
Disallow root login remotely? [Y/n] y 禁止root远程登录
... Success!
Remove test database and access to it? [Y/n] y 删除test数据库
- Dropping test database...
... Success!
- Removing privileges on test database...
... Success!
Reload privilege tables now? [Y/n] y 刷新授权表，让初始化生效
... Success!
```

- 启动并查看数据库状态

```bash
[root@node1 ~]# systemctl start mariadb.service
[root@node1 ~]# systemctl status mariadb.service
● mariadb.service - MariaDB database server
Loaded: loaded (/usr/lib/systemd/system/mariadb.service; disabled; vendor
preset: disabled)
Active: active (running) since 一 2020-09-14 22:38:17 CST; 10s ago
Process: 1634 ExecStartPost=/usr/libexec/mariadb-wait-ready $MAINPID
(code=exited, status=0/SUCCESS)
Process: 1550 ExecStartPre=/usr/libexec/mariadb-prepare-db-dir %n
(code=exited, status=0/SUCCESS)
Main PID: 1633 (mysqld_safe)
```

- 登录数据库

```bash
[root@node1 ~]# mysql -uroot -p
Enter password:
Welcome to the MariaDB monitor. Commands end with ; or \g.
Your MariaDB connection id is 2
MariaDB [(none)]>
```



- 主配置文件

```bash
[root@node1 ~]# vim /etc/my.cnf
[client] # 客户端基本配置
port = 3306 #客户端默认连接端口
socket = /tmp/mysql.sock #用于本地连接的socket套接字
[mysqld] # 服务端基本配置
port = 3306 # mysql监听端口
socket = /tmp/mysql.sock #为MySQL客户端程序和服务器之间的本地通讯指定一个套接字文件
user = mariadb # mysql启动用户
basedir = /usr/local/mariadb # 安装目录
datadir = /data/mysql # 数据库数据文件存放目录
log_error = /data/mysql/mariadb.err #记录错误日志文件
pid-file = /data/mysql/mariadb.pid #pid所在的目录
skip-external-locking #不使用系统锁定，要使用myisamchk,必须关闭服务器
```



# 基础管理

### 管理员密码的设定

```bash
[root@localhost ~]# mysqladmin -uroot -p password 1
Enter password: <首次设置直接回车，第二次修改密码时此处输入旧密码>

#管理员密码忘记
#关闭数据库
1 [root@localhost ~]# systemctl stop mariadb.service
#跳过授权登录
mysqld_safe --skip-grant-tables --skip-networking &

#登录mysql并修改root密码
[root@localhost ~]# mysql
MariaDB [(none)]> use mysql
MariaDB [mysql]> grant all on *.* to root@'localhost' identified by '777';
ERROR 1290 (HY000): The MariaDB server is running with the --skip-granttables
option so it cannot execute this statement

MariaDB [mysql]> flush privileges;
Query OK, 0 rows affected (0.00 sec)

MariaDB [mysql]> grant all on *.* to root@'localhost' identified by '777';
Query OK, 0 rows affected (0.00 sec)

#重启数据库
[root@localhost ~]# pkill mysqld
[root@localhost ~]# systemctl restart mariadb

```

### 忘记密码

在MySQL登录时出现Access denied for user 'root'@'localhost' (using password: YES) 拒绝访问

![img](https://img2018.cnblogs.com/blog/1406024/201904/1406024-20190412105518466-1510768456.png)

![img](https://img2018.cnblogs.com/blog/1406024/201904/1406024-20190412105911515-2081886476.png)

 

对于出现拒绝访问root用户的解决方案
错误1045（28000）：用户'root'@'localhost'（使用密码：YES）拒绝访问

首先解析此英文：ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: YES)；
解析的地方有两处：1.Access denied（拒绝访问）；2.using password：NO/YES

 

一、出现access denied的原因有如下可能：

1）mysql的服务器停止：
　　若MySQL已经没有启动，重启MySQL服务器：systemctl restart mysqld
2）用户的端口号或者IP导致：
　　若用户的端口号与IP（3306/3307）不一致，打开my.ini文件进行编辑。全部编辑替换为： port=X
3）mysql的配置文件错误----my.ini等文件：
　　my.ini文件误输入无效内容，不知道到何处。复制替换该文件；有人已经对my.ini文件进行解释以及注释：https://blog.csdn.net/lienfeng6/article/details/78140404
4）root用户的密码错误（后面解决）

 

二、出现 using password的原因如下：

 

不输入密码：

![img](https://img2018.cnblogs.com/blog/1406024/201904/1406024-20190412111234724-1010496914.png)

错误的密码：

![img](https://img2018.cnblogs.com/blog/1406024/201904/1406024-20190412111455287-1046376355.png)

 

解决方案：
vim /etc/my.cnf文件；
在[mysqld]后添加skip-grant-tables（登录时跳过权限检查）
![img](https://img2018.cnblogs.com/blog/1406024/201904/1406024-20190412113328448-646131746.png)

 

重启MySQL服务：sudo systemctl restart mysqld

![img](https://img2018.cnblogs.com/blog/1406024/201904/1406024-20190412113431610-865569898.png)

修改密码

![img](https://img2018.cnblogs.com/blog/1406024/201904/1406024-20190412113849058-1137877631.png)

![img](https://img2018.cnblogs.com/blog/1406024/201904/1406024-20190412113940253-545922564.png)

 

登录mysql，输入mysql –uroot –p；直接回车（Enter）

![img](https://img2018.cnblogs.com/blog/1406024/201904/1406024-20190412114640768-474146914.png)

 

输入：set password for ‘root’@‘localhost’=password(‘Admin123@qwe’);

如果报：ERROR 1290 (HY000): The MySQL server is running with the --skip-grant-tables option so it cannot execute this statement![img](https://img2018.cnblogs.com/blog/1406024/201904/1406024-20190412123249095-1932237484.png)

输入：flush privileges;

![img](https://img2018.cnblogs.com/blog/1406024/201904/1406024-20190412123407017-735059880.png)

再次输入：set password for ‘root’@‘localhost’=password(‘Admin123@qwe’);

![img](https://img2018.cnblogs.com/blog/1406024/201904/1406024-20190412123456394-132791315.png)

为避免麻烦，再次设置远程访问

GRANT ALL PRIVILEGES ON *.* TO 'root'@'%'IDENTIFIED BY 'Admin123@qwe' WITH GRANT OPTION;

flush privileges;

![img](https://img2018.cnblogs.com/blog/1406024/201904/1406024-20190412123703166-968137354.png)

退出：exit

![img](https://img2018.cnblogs.com/blog/1406024/201904/1406024-20190412123741003-1269403461.png)

 

再把my.ini的skip-grant-tables删除或者注释掉

![img](https://img2018.cnblogs.com/blog/1406024/201904/1406024-20190412123853248-2074786669.png)

重启MySQL：sudo systemctl restart mysqld

## 客户端工具

- mysql可以用来连接数据库
  -  --user , -u 
  - --host , -h 
  - --password ,-p 
  - --port --protocol 
  - --database DATABASE , -D 登录指定数据库 
- mysqladmin(可以通过客户端直接执⾏服务器上的命令

```bash
[root@localhost ~]# mysqladmin -uroot -p1 create hellodb
[root@localhost ~]# mysqladmin -uroot -p1 ping 检查服务端存活状态的
[root@localhost ~]# mysqladmin -uroot -p1 status 服务器详细运行状态
[root@localhost ~]# mysqladmin -uroot -p1 status 服务器状态 --sleep 2 --count
10 每两秒钟显示
⼀次服务器实时状态⼀共显示10次
[root@localhost ~]# mysqladmin -uroot -p1 extended-status 显示状态变量
[root@localhost ~]# mysqladmin -uroot -p1 variables 显示服务器变量
[root@localhost ~]# mysqladmin -uroot -p1 flush-privileges 数据库重读授权表，等
同于reload
[root@localhost ~]# mysqladmin -uroot -p1 flush-tables 关闭所有已经打开的表
[root@localhost ~]# mysqladmin -uroot -p1 flush-threds 重置线程池缓存
[root@localhost ~]# mysqladmin -uroot -p1 flush-status 重置⼤多数服务器状态变量
[root@localhost ~]# mysqladmin -uroot -p1 flush-logs ⽇志滚动。主要实现⼆进制和中
继⽇志滚动
[root@localhost ~]# mysqladmin -uroot -p1 flush-hosts 清楚主机内部信息
[root@localhost ~]# mysqladmin -uroot -p1 kill 杀死线程
[root@localhost ~]# mysqladmin -uroot -p1 refresh 相当于同时执⾏flush-hosts
flush-logs
[root@localhost ~]# mysqladmin -uroot -p1 shutdown 关闭服务器进程
[root@localhost ~]# mysqladmin -uroot -p1 version 服务器版本以及当前状态信息
[root@localhost ~]# mysqladmin -uroot -p1 start-slave 启动复制，启动从服务器复制
线程
[root@localhost ~]# mysqladmin -uroot -p1 stop-slave 关闭复制线程
```

- 在数据库的语句中可以加的命令
  - \C：提前终⽌语句执⾏
  -  \d： 修改默认结束符
  - \g：⽆论语句结束符是什么，直接将此语句送⾄服务器执⾏
  -  \G：⽆论语句结束符是什么，直接将结果送⾄服务端执⾏，⽽且结果以竖排⽅式显示
  -  !：执⾏shell命令 
  - \W：显示语句结束后显示警告信息
  -  \w：不显示警告信息 默认输出的格式是表的格式。登录数据库时可以添加参数 --html -H 或者 --xml -X

```bash
MariaDB [(none)]> show databases;
+--------------------+
| Database |
+--------------------+
| information_schema |
| mysql |
| performance_schema |
+--------------------+
3 rows in set (0.00 sec)
MariaDB [(none)]> show databases\G
*************************** 1. row ***************************
Database: information_schema
*************************** 2. row ***************************
Database: mysql
*************************** 3. row ***************************
Database: performance_schema
3 rows in set (0.00 sec)
```



## 基础SQL语句

```bash
#操作文件夹
增：create database db1 charset utf8;
查：show databases;
改：alter database db1 charset latin1;
删除: drop database db1;

#操作文件（表）
先切换到文件夹下：use db1
增：create table t1(id int,name char);
查：show tables;
改：alter table t1 modify name char(3);
alter table t1 change name name1 char(2);
删：drop table t1;

#操作文件中的内容（记录）
增：insert into t1 values(1,'xwz'),(2,'cs'),(3,'tj');
查：select * from t1;
改：update t1 set name='sb' where id=2;
删：delete from t1 where id=1;
清空表：
delete from t1; #如果有自增id，新增的数据，仍然是以删除前的最后一样作为起始。
truncate table t1;数据量大，删除速度比上一条快，且直接从零开始，
```



# MySQL体系结构 

## C/S(客户端/服务端)模型介绍

![image-20220416114718236](http://cdn.gtrinee.top/image-20220416114718236.png)



## 连接方式

```bash
#tcp连接 （适用于远程登录）
[root@localhost ~]# mysql -uroot -p777 -h 192.168.80.128 -P3306

#socket连接
[root@localhost ~]# mysql -uroot -p -S /tmp/mysql.sock 
#文件目录在配置文件中 /etc/my.conf
```



**实例介绍**

实例=mysqld后台守护进程+Master Thread +干活的Thread+预分配的内存

公司=老板+经理+员工+办公室

## 工作流程

![image-20220416115012343](http://cdn.gtrinee.top/image-20220416115012343.png)

```bash
1. 首先，最上层的服务并不是MySQL独有的，大多数给予网络的客户端/服务器的工具或者服务都有
类似的架 构。比如：连接处理、授权认证、安全等。
2. 第二层的架构包括大多数的MySQL的核心服务。包括：查询解析、分析、优化、缓存以及所有的内
置函数 （例如：日期、时间、数学和加密函数）。同时，所有的跨存储引擎的功能都在这一层实
现：存储过程、触发 器、视图等。
3. 第三层包含了存储引擎。存储引擎负责MySQL中数据的存储和提取。服务器通过API和存储引擎进
行通信。这 些接口屏蔽了不同存储引擎之间的差异，使得这些差异对上层的查询过程透明化。存储
引擎API包含十几个底 层函数，用于执行“开始一个事务”等操作。但存储引擎一般不会去解析
SQL（InnoDB会解析外键定义，因为其 本身没有实现该功能），不同存储引擎之间也不会相互通
信，而只是简单的响应上层的服务器请求。
4. 第四层包含了文件系统，所有的表结构和数据以及用户操作的日志最终还是以文件的形式存储在硬
盘上
```



## 程序结构

我们把MySQL的体系结构称为**插件式存储引擎结构。**

![image-20220416115238164](http://cdn.gtrinee.top/image-20220416115238164.png)



- 连接层功能 
  - 提供连接协议：TCP/IP 、SOCKET
  -  提供验证：用户、密码，IP，SOCKET 
  - 提供专用连接线程：接收用户SQL，返回结果

```bash
#通过以下语句可以查看到连接线程基本情况
MariaDB [(none)]> show processlist;
+----+------+-----------+------+---------+------+-------+------------------+----------+
| Id | User | Host | db | Command | Time | State | Info |
Progress |
+----+------+-----------+------+---------+------+-------+------------------+----------+
| 2 | root | localhost | NULL | Sleep | 6792 | | NULL |
0.000 |
| 4 | root | localhost | NULL | Query | 0 | NULL | show processlist |
0.000 |
+----+------+-----------+------+---------+------+-------+------------------+----------+

```

### SQL层（重点）

**主要有****SQL Interface、***Parser、****Optimizer、****Cache和Buffer**

**Sql层功能:**

**功能：解析器,授权,优化器,查询执行,查询高速缓存,查询日志记录，跨存储引擎功能。**

1.解析器：解析SQL语法，形成语法树

2.授权:SQL的权限验证  *.*对于指定的库和表

3.优化器:CBO（基于成本的优化）,根据统计信息--> SQL改写 --->执行计划(即选哪种算法执行)

**sql层处理数据流程：**

```bash
用户传入sql-----查询缓存（命中缓存可直接返回结果）----解析器（生成sql解析树）----预处理器（可能sql等价改写）-----查询优化器（生成sql执行计划）----查询执行引擎----结果返回给用户。
 
```

**存储引擎层** 

- 负责根据SQL层执行的结果，从磁盘上拿数据 
- 将16进制的磁盘数据，交由SQL结构化化成表 
- 连接层的专用线程返回给用户

## 逻辑结构

- 库
  - 库名
  - 属性
  - 用文件系统的目录来存储

```bash
[root@localhost mysql]# ll
总用量 28700
-rw-rw----. 1 mysql mysql 16384 9月 6 20:31 aria_log.00000001
-rw-rw----. 1 mysql mysql 52 9月 6 20:31 aria_log_control
-rw-rw----. 1 mysql mysql 18874368 9月 6 20:31 ibdata1
-rw-rw----. 1 mysql mysql 5242880 9月 6 20:31 ib_logfile0
-rw-rw----. 1 mysql mysql 5242880 9月 6 19:45 ib_logfile1
drwx------. 2 mysql mysql 4096 9月 6 19:45 mysql
srwxrwxrwx. 1 mysql mysql 0 9月 6 20:31 mysql.sock
drwx------. 2 mysql mysql 4096 9月 6 19:45 performance_schema
drwx------. 2 mysql mysql 6 9月 6 19:45 test
=====================================================================
MariaDB [(none)]> show databases;
+--------------------+
| Database |
+--------------------+
| information_schema |
| mysql |
| performance_schema |
| test |
+--------------------+
```

- 表
  - 表名
  - 属性
  - 列
  - 数据行
  - 用文件系统的文件来存储

```bash
[root@localhost mysql]# cd mysql/
[root@localhost mysql]# ll
总用量 1000
-rw-rw----. 1 mysql mysql 8820 9月 6 19:45 columns_priv.frm
-rw-rw----. 1 mysql mysql 0 9月 6 19:45 columns_priv.MYD
-rw-rw----. 1 mysql mysql 4096 9月 6 19:45 columns_priv.MYI
-rw-rw----. 1 mysql mysql 9582 9月 6 19:45 db.frm
-rw-rw----. 1 mysql mysql 880 9月 6 19:45 db.MYD
-rw-rw----. 1 mysql mysql 5120 9月 6 19:45 db.MYI
-rw-rw----. 1 mysql mysql 10239 9月 6 19:45 event.frm
-rw-rw----. 1 mysql mysql 0 9月 6 19:45 event.MYD
......
-rw-rw----. 1 mysql mysql 10630 9月 6 19:45 user.frm
-rw-rw----. 1 mysql mysql 544 9月 6 20:22 user.MYD
-rw-rw----. 1 mysql mysql 2048 9月 6 20:30 user.MYI
=====================================================================
MariaDB [(none)]> use mysql
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A
Database changed
MariaDB [mysql]> show tables;
+---------------------------+
| Tables_in_mysql |
+---------------------------+
| columns_priv |
| db |
| event |
| func |
......
| user |
+---------------------------+
```



# 存储引擎（重点)

- 功能 
  - 数据读写 
  - 数据安全
  -  提高性能
  -  热备份 
  - 自动故障恢复 
  - 高可用方面支持

## **存储引擎分类介绍**

下面就简单介绍一下MySQL的存储引擎。

## **InnoDB**

InnoDB是一个健壮的**事务型存储引擎**，这种存储引擎已经被很多互联网公司使用，为用户操作非常大的数据存储提供了一个强大的解决方案。

InnoDB还引入了行级锁定和外键约束，在以下场合下，使用InnoDB是最理想的选择：

- 更新密集的表。 InnoDB存储引擎特别适合处理多重并发的更新请求。
- 事务。 **InnoDB存储引擎是支持事务的标准MySQL存储引擎。**
- **自动灾难恢复**。 与其它存储引擎不同，InnoDB表能够自动从灾难中恢复。
- 外键约束。 **MySQL支持外键的存储引擎只有InnoDB。**
- 支持自动增加列AUTO_INCREMENT属性。
- 从5.7开始innodb存储引擎成为默认的存储引擎。

一般来说，如果需要事务支持，并且有较高的并发读取频率，InnoDB是不错的选择。

## **MyISAM**

MyISAM表是独立于操作系统的，这说明可以轻松地将其从Windows服务器移植到Linux服务器。

每当我们建立一个MyISAM引擎的表时，就会在本地磁盘上建立三个文件，文件名就是表名。

例如，我建立了一个MyISAM引擎的tb_Demo表，那么就会生成以下三个文件：

- tb_demo.frm，存储表定义。
- tb_demo.MYD，存储数据。
- tb_demo.MYI，存储索引。

MyISAM表无法处理事务，这就意味着有事务处理需求的表，不能使用MyISAM存储引擎。MyISAM存储引擎特别适合在以下几种情况下使用：

\1. 选择密集型的表。 MyISAM存储引擎在筛选大量数据时非常迅速，这是它最突出的优点。

\2. 插入密集型的表。 MyISAM的并发插入特性允许同时选择和插入数据。

由此看来，MyISAM存储引擎很适合管理服务器日志数据。

## **MRG_MYISAM**

MRG_MyISAM存储引擎是一组MyISAM表的组合，老版本叫 MERGE 其实是一回事儿。

这些MyISAM表结构必须完全相同，尽管其使用不如其它引擎突出，但是在某些情况下非常有用。

说白了，Merge表就是几个相同MyISAM表的聚合器；Merge表中并没有数据，对Merge类型的表可以进行查询、更新、删除操作，这些操作实际上是对内部的MyISAM表进行操作。

## **Merge存储引擎的使用场景**

对于服务器日志这种信息，一般常用的存储策略是将数据分成很多表，每个名称与特定的时间段相关。

例如，可以用12个相同的表来存储服务器日志数据，每个表用对应各个月份的名字来命名。当有必要基于所有12个日志表的数据来生成报表，这意味着需要编写并更新多表查询，以反映这些表中的信息。与其编写这些可能出现错误的查询，不如将这些表合并起来使用一条查询，之后再删除Merge表，而不影响原来的数据，删除Merge表只是删除Merge表的定义，对内部的表没有任何影响。

## **常用引擎对比**

不同存储引起都有各自的特点，为适应不同的需求，需要选择不同的存储引擎，所以首先考虑这些存储引擎各自的功能和兼容。

![img](https://pic3.zhimg.com/80/v2-c20d4d233709af603d573ea26737814a_720w.jpg)

##  存储引擎相关操作

**查看存储引擎**
使用“SHOW VARIABLES LIKE '%storage_engine%';” 命令在mysql系统变量搜索默认设置的存储引擎，输入语句如下：

```text
mysql> SHOW VARIABLES LIKE '%storage_engine%'; 
+----------------------------------+---------+ 
| Variable_name                    | Value   |
|----------------------------------+---------| 
| default_storage_engine           | InnoDB  | 
| default_tmp_storage_engine       | InnoDB  | 
| disabled_storage_engines         |         | 
| internal_tmp_disk_storage_engine | InnoDB  | 
+----------------------------------+---------+ 
4 rows in set 
Time: 0.005s
```

使用`SHOW ENGINES;`命令显示安装以后**可用的所有的支持的存储引擎和默认引擎**，后面带上 `\G` 可以列表输出结果，你可以尝试一下`SHOW ENGINES\G;`。

```text
mysql> SHOW ENGINES; 
+--------------------+---------+--------------------------------------+-------------+--------+-----------+ 
| Engine             | Support | Comment                              | Transactions| XA     | Savepoints| 
|--------------------+---------+--------------------------------------+-------------+--------+-----------| 
| InnoDB             | DEFAULT | Supports transactions,               | YES         | YES    | YES       | 
|                    |         | row-level locking, and foreign keys  |             |        |           | 
| MRG_MYISAM         | YES     | Collection of identical MyISAM tables| NO          | NO     | NO        | 
| MEMORY             | YES     | Hash based, stored in memory, useful | NO          | NO     | NO        | 
|                    |         | for temporary tables                 |             |        |           | 
| BLACKHOLE          | YES     | /dev/null storage engine (anything   | NO          | NO     | NO        | 
|                    |         | you write to it disappears)          |             |        |           | 
| MyISAM             | YES     | MyISAM storage engine                | NO          | NO     | NO        |
| CSV                | YES     | CSV storage engine                   | NO          | NO     | NO        | 
| ARCHIVE            | YES     | Archive storage engine               | NO          | NO     | NO        | 
| PERFORMANCE_SCHEMA | YES     | Performance Schema                   | NO          | NO     | NO        | 
| FEDERATED          | NO      | Federated MySQL storage engine       | <null>      | <null> | <null>    | 
+--------------------+---------+--------------------------------------+-------------+--------+-----------+
```

由上面命令输出，可见当前系统的默认数据表类型是InnoDB。当然，我们可以通过修改数据库配置文件中的选项，设定默认表类型。

**设置存储引擎**
对上面数据库存储引擎有所了解之后，你可以在`my.cnf` 配置文件中设置你需要的存储引擎，这个参数放在 [mysqld] 这个字段下面的 default_storage_engine 参数值，例如下面配置的片段

```text
[mysqld] 
default_storage_engine=CSV
```

**在创建表的时候，对表设置存储引擎**
例如：

```text
 CREATE TABLE `user` (
   `id`     int(100) unsigned NOT NULL AUTO_INCREMENT,
   `name`   varchar(32) NOT NULL DEFAULT '' COMMENT '姓名',
   `mobile` varchar(20) NOT NULL DEFAULT '' COMMENT '手机',
   PRIMARY KEY (`id`) 
 )ENGINE=InnoDB;
```

在创建用户表 user 的时候，SQL语句最后 ENGINE=InnoDB 就是设置这张表存储引擎为 InnoDB。

# SQL语句

## 用户管理

- 创建用户

```bash
MariaDB [(none)]> create user eagle@192.168.33.128 identified by '1';
Query OK, 0 rows affected (0.00 sec)
```

- 查询用户

```bash
MariaDB [(none)]> select user,host,password from mysql.user;
+-------+----------------+-------------------------------------------+
| user | host | password |
+-------+----------------+-------------------------------------------+
| root | localhost | *E8D868B7DA46FC9F996DC761C1AE01754A4447D5 |
| root | 127.0.0.1 | *7FB1F1B8AD1B4CFD578E76ABC1B6ADFF70D04FA0 |
| root | ::1 | *7FB1F1B8AD1B4CFD578E76ABC1B6ADFF70D04FA0 |
| eagle | 192.168.33.128 | *E6CC90B878B948C35E92B003C792C46C58C4AF40 |
+-------+----------------+-------------------------------------------+

```

- 修改用户密码

```bash
MariaDB [(none)]> use mysql
MariaDB [mysql]> update user set password=password('2') where user='eagle'
and host='192.168.33.128';
Query OK, 1 row affected (0.00 sec)
Rows matched: 1 Changed: 1 Warnings: 0
```

- 删除用户

```bash
MariaDB [(none)]> drop user eagle@192.168.33.128;
Query OK, 0 rows affected (0.00 sec)
```

## 权限管理

- 授权

```bash
MariaDB [(none)]> grant all on *.* to eagle@'%' identified by '123';
# *.* *是占位符 给所有库所有表all权限给eagle
```

- 常用权限介绍

```bash
ALL:
SELECT,INSERT, UPDATE, DELETE, CREATE, DROP, RELOAD, SHUTDOWN, PROCESS, FILE,
REFERENCES, INDEX, ALTER, SHOW DATABASES, SUPER, CREATE TEMPORARY TABLES,
LOCK TABLES, EXECUTE, REPLICATION SLAVE, REPLICATION CLIENT, CREATE VIEW,
SHOW VIEW, CREATE ROUTINE, ALTER ROUTINE, CREATE USER, EVENT, TRIGGER, CREATE
TABLESPACE
ALL : 以上所有权限，一般是普通管理员拥有的
with grant option：超级管理员才具备的，给别的用户授权的功能
```

- 权限作用范围

```bash
*.* # 针对所有数据库里的所有表
db1.* # 针对db1数据库里的所有表
db1.tb1 # 针对db1数据库里的表tb1
```

- 查看授权

```bash
MariaDB [(none)]> show grants for root@'localhost'\G;
*************************** 1. row ***************************
Grants for root@localhost: GRANT ALL PRIVILEGES ON *.* TO 'root'@'localhost'
IDENTIFIED BY PASSWORD '*E8D868B7DA46FC9F996DC761C1AE01754A4447D5' WITH GRANT
OPTION
*************************** 2. row ***************************
Grants for root@localhost: GRANT PROXY ON ''@'' TO 'root'@'localhost' WITH
GRANT OPTION
2 rows in set (0.00 sec)
```

- 回收权限

```bash
MariaDB [(none)]> revoke delete on *.* from eagle@'%'；
```

- 案例1，在本地Windows主机上使用navicat登录到虚拟机里的MySQL，通常会由于没有授权而被 拒绝

```bash
MariaDB [(none)]> grant all on *.* to root@'192.168.33.%' identified by
'777';
```

## 数据库表

- 创建表

```bash
#语法：
create table 表名(
字段名1 类型[(宽度) 约束条件],
字段名2 类型[(宽度) 约束条件],
字段名3 类型[(宽度) 约束条件]
);
#注意：
1. 在同一张表中，字段名是不能相同
2. 宽度和约束条件可选
3. 字段名和类型是必须的

mysql> create table staff_info (
id int,name varchar(50),
age int(3),
sex enum('male','female'),
phone bigint(11),
job varchar(11)
);
Query OK, 0 rows affected (0.02 sec)
```

- 插入数据

```bash
mysql> insert into staff_info (id,name,age,sex,phone,job) values
(1,'xwz',83,'female',13651054608,'IT');
Query OK, 1 row affected (0.00 sec)

mysql> insert into staff_info values
(2,'cs',26,'male',13304320533,'Teacher');
Query OK, 1 row affected (0.00 sec)
 
mysql> insert into staff_info values (3,'tj',25,'male',13332353222,'IT'),
(4,'fcy',40,'male',13332353333,'IT');
Query OK, 2 rows affected (0.00 sec)
```

- 查看表的结构

```bash
mysql> describe staff_info;
+-------+-----------------------+------+-----+---------+-------+
| Field | Type | Null | Key | Default | Extra |
+-------+-----------------------+------+-----+---------+-------+
| id | int(11) | YES | | NULL | |
| name | varchar(50) | YES | | NULL | |
| age | int(3) | YES | | NULL | |
| sex | enum('male','female') | YES | | NULL | |
| phone | bigint(11) | YES | | NULL | |
| job | varchar(11) | YES | | NULL | |
+-------+-----------------------+------+-----+---------+-------+
6 rows in set (0.00 sec)
# 更全面的表定义信息
mysql> show create table staff_info\G;
*************************** 1. row ***************************
Table: staff_info
Create Table: CREATE TABLE `staff_info` (
`id` int(11) DEFAULT NULL,
`name` varchar(50) DEFAULT NULL,
`age` int(3) DEFAULT NULL,
`sex` enum('male','female') DEFAULT NULL,
`phone` bigint(11) DEFAULT NULL,
`job` varchar(11) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8
1 row in set (0.01 sec)
```

- 修改表结构的语法

```bash
1. 修改表名
ALTER TABLE 表名
RENAME 新表名;
2. 增加字段
ALTER TABLE 表名
ADD 字段名 数据类型 [完整性约束条件…],
ADD 字段名 数据类型 [完整性约束条件…];
3. 删除字段
ALTER TABLE 表名
DROP 字段名;
4. 修改字段
ALTER TABLE 表名
MODIFY 字段名 数据类型 [完整性约束条件…];
ALTER TABLE 表名
CHANGE 旧字段名 新字段名 旧数据类型 [完整性约束条件…];
ALTER TABLE 表名
CHANGE 旧字段名 新字段名 新数据类型 [完整性约束条件…];
5.修改字段排列顺序/在增加的时候指定字段位置
ALTER TABLE 表名
ADD 字段名 数据类型 [完整性约束条件…] FIRST;
ALTER TABLE 表名
ADD 字段名 数据类型 [完整性约束条件…] AFTER 字段名;
ALTER TABLE 表名
CHANGE 字段名 旧字段名 新字段名 新数据类型 [完整性约束条件…] FIRST;
ALTER TABLE 表名
MODIFY 字段名 数据类型 [完整性约束条件…] AFTER 字段名;
```

- 修改表的实例

```bash
mysql> desc staff_info;
+-------+-----------------------+------+-----+---------+-------+
| Field | Type | Null | Key | Default | Extra |
+-------+-----------------------+------+-----+---------+-------+
| id | int(11) | YES | | NULL | |
| name | varchar(50) | YES | | NULL | |
| age | int(3) | YES | | NULL | |
| sex | enum('male','female') | YES | | NULL | |
| phone | bigint(11) | YES | | NULL | |
| job | varchar(11) | YES | | NULL | |
+-------+-----------------------+------+-----+---------+-------+
6 rows in set (0.00 sec)

# 表重命名
mysql> alter table staff_info rename staff;
Query OK, 0 rows affected (0.00 sec)
mysql> desc staff;
+-------+-----------------------+------+-----+---------+-------+
| Field | Type | Null | Key | Default | Extra |
+-------+-----------------------+------+-----+---------+-------+
| id | int(11) | YES | | NULL | |
| name | varchar(50) | YES | | NULL | |
| age | int(3) | YES | | NULL | |
| sex | enum('male','female') | YES | | NULL | |
| phone | bigint(11) | YES | | NULL | |
| job | varchar(11) | YES | | NULL | |
+-------+-----------------------+------+-----+---------+-------+
6 rows in set (0.00 sec)

# 删除sex列
mysql> alter table staff drop sex;
Query OK, 0 rows affected (0.02 sec)
Records: 0 Duplicates: 0 Warnings: 0
mysql> desc staff;
+-------+-------------+------+-----+---------+-------+
| Field | Type | Null | Key | Default | Extra |
+-------+-------------+------+-----+---------+-------+
| id | int(11) | YES | | NULL | |
| name | varchar(50) | YES | | NULL | |
| age | int(3) | YES | | NULL | |
| phone | bigint(11) | YES | | NULL | |
| job | varchar(11) | YES | | NULL | |
+-------+-------------+------+-----+---------+-------+
5 rows in set (0.01 sec)

# 添加列
mysql> alter table staff add sex enum('male','female');
Query OK, 0 rows affected (0.03 sec)
Records: 0 Duplicates: 0 Warnings: 0

# 修改id的宽度
mysql> alter table staff modify id int(4);
Query OK, 0 rows affected (0.02 sec)
Records: 0 Duplicates: 0 Warnings: 0
mysql> desc staff;
+-------+-----------------------+------+-----+---------+-------+
| Field | Type | Null | Key | Default | Extra |
+-------+-----------------------+------+-----+---------+-------+
| id | int(4) | YES | | NULL | |
| name | varchar(50) | YES | | NULL | |
| age | int(3) | YES | | NULL | |
| phone | bigint(11) | YES | | NULL | |
| job | varchar(11) | YES | | NULL | |
| sex | enum('male','female') | YES | | NULL | |
+-------+-----------------------+------+-----+---------+-------+
6 rows in set (0.01 sec)

# 修改name列的字段名
mysql> alter table staff change name sname varchar(20);
Query OK, 4 rows affected (0.03 sec)
Records: 4 Duplicates: 0 Warnings: 0
mysql> desc staff;
+-------+-----------------------+------+-----+---------+-------+
| Field | Type | Null | Key | Default | Extra |
+-------+-----------------------+------+-----+---------+-------+
| id | int(4) | YES | | NULL | |
| sname | varchar(20) | YES | | NULL | |
| age | int(3) | YES | | NULL | |
| phone | bigint(11) | YES | | NULL | |
| job | varchar(11) | YES | | NULL | |
| sex | enum('male','female') | YES | | NULL | |
+-------+-----------------------+------+-----+---------+-------+
6 rows in set (0.00 sec)

# 修改sex列的位置
mysql> alter table staff modify sex enum('male','female') after sname;
Query OK, 0 rows affected (0.02 sec)
Records: 0 Duplicates: 0 Warnings: 0
mysql> desc staff;
+-------+-----------------------+------+-----+---------+-------+
| Field | Type | Null | Key | Default | Extra |
+-------+-----------------------+------+-----+---------+-------+
| id | int(4) | YES | | NULL | |
| sname | varchar(20) | YES | | NULL | |
| sex | enum('male','female') | YES | | NULL | |
| age | int(3) | YES | | NULL | |
| phone | bigint(11) | YES | | NULL | |
| job | varchar(11) | YES | | NULL | |
+-------+-----------------------+------+-----+---------+-------+
6 rows in set (0.00 sec)

# 创建自增id主键
mysql> alter table staff modify id int(4) primary key auto_increment;
Query OK, 4 rows affected (0.02 sec)
Records: 4 Duplicates: 0 Warnings: 0
mysql> desc staff;
+-------+-----------------------+------+-----+---------+----------------+
| Field | Type | Null | Key | Default | Extra |
+-------+-----------------------+------+-----+---------+----------------+
| id | int(4) | NO | PRI | NULL | auto_increment |
| sname | varchar(20) | YES | | NULL | |
| sex | enum('male','female') | YES | | NULL | |
| age | int(3) | YES | | NULL | |
| phone | bigint(11) | YES | | NULL | |
| job | varchar(11) | YES | | NULL | |
+-------+-----------------------+------+-----+---------+----------------+
6 rows in set (0.00 sec)

# 删除主键，可以看到删除一个自增主键会报错
mysql> alter table staff drop primary key;
ERROR 1075 (42000): Incorrect table definition; there can be only one auto
column and it
must be defined as a key

# 需要先去掉主键的自增约束，然后再删除主键约束
mysql> alter table staff modify id int(11);
Query OK, 4 rows affected (0.02 sec)
Records: 4 Duplicates: 0 Warnings: 0
mysql> desc staff;
+-------+-----------------------+------+-----+---------+-------+
| Field | Type | Null | Key | Default | Extra |
+-------+-----------------------+------+-----+---------+-------+
| id | int(11) | NO | PRI | 0 | |
| sname | varchar(20) | YES | | NULL | |
| sex | enum('male','female') | YES | | NULL | |
| age | int(3) | YES | | NULL | |
| phone | bigint(11) | YES | | NULL | |
| job | varchar(11) | YES | | NULL | |
+-------+-----------------------+------+-----+---------+-------+
6 rows in set (0.01 sec)
mysql> alter table staff drop primary key;
Query OK, 4 rows affected (0.06 sec)
Records: 4 Duplicates: 0 Warnings: 0

# 添加联合主键
mysql> alter table staff add primary key (sname,age);
Query OK, 0 rows affected (0.02 sec)
Records: 0 Duplicates: 0 Warnings: 0

# 删除主键
mysql> alter table staff drop primary key;
Query OK, 4 rows affected (0.02 sec)
Records: 4 Duplicates: 0 Warnings: 0

# 创建主键id
mysql> alter table staff add primary key (id);
Query OK, 0 rows affected (0.02 sec)
Records: 0 Duplicates: 0 Warnings: 0
mysql> desc staff;
+-------+-----------------------+------+-----+---------+-------+
| Field | Type | Null | Key | Default | Extra |
+-------+-----------------------+------+-----+---------+-------+
| id | int(11) | NO | PRI | 0 | |
| sname | varchar(20) | NO | | | |
| sex | enum('male','female') | YES | | NULL | |
| age | int(3) | NO | | 0 | |
| phone | bigint(11) | YES | | NULL | |
| job | varchar(11) | YES | | NULL | |
+-------+-----------------------+------+-----+---------+-------+
6 rows in set (0.00 sec)

# 为主键添加自增属性
mysql> alter table staff modify id int(4) auto_increment;
Query OK, 4 rows affected (0.02 sec)
Records: 4 Duplicates: 0 Warnings: 0
mysql> desc staff;
+-------+-----------------------+------+-----+---------+----------------+
| Field | Type | Null | Key | Default | Extra |
+-------+-----------------------+------+-----+---------+----------------+
| id | int(4) | NO | PRI | NULL | auto_increment |
| sname | varchar(20) | NO | | | |
| sex | enum('male','female') | YES | | NULL | |
| age | int(3) | NO | | 0 | |
| phone | bigint(11) | YES | | NULL | |
| job | varchar(11) | YES | | NULL | |
+-------+-----------------------+------+-----+---------+----------------+
6 rows in set (0.00 sec)
```



一个数据库通常包含一个或多个表。每个表有一个名字标识（例如:"Websites"）,表包含带有数据的记录（行）。

在本教程中，我们在 MySQL 的 RUNOOB 数据库中创建了 Websites 表，用于存储网站记录。

我们可以通过以下命令查看 "Websites" 表的数据：

```
mysql> use RUNOOB;
Database changed

mysql> set names utf8;
Query OK, 0 rows affected (0.00 sec)

mysql> SELECT * FROM Websites;
+----+--------------+---------------------------+-------+---------+
| id | name         | url                       | alexa | country |
+----+--------------+---------------------------+-------+---------+
| 1  | Google       | https://www.google.cm/    | 1     | USA     |
| 2  | 淘宝          | https://www.taobao.com/   | 13    | CN      |
| 3  | 菜鸟教程      | http://www.runoob.com/    | 4689  | CN      |
| 4  | 微博          | http://weibo.com/         | 20    | CN      |
| 5  | Facebook     | https://www.facebook.com/ | 3     | USA     |
+----+--------------+---------------------------+-------+---------+
5 rows in set (0.01 sec)
```

### 解析

- **use RUNOOB;** 命令用于选择数据库。
- **set names utf8;** 命令用于设置使用的字符集。
- **SELECT \* FROM Websites;** 读取数据表的信息。
- 上面的表包含五条记录（每一条对应一个网站信息）和5个列（id、name、url、alexa 和country）。

## 请记住...

- SQL 对大小写不敏感：SELECT 与 select 是相同的。

## 一些最重要的 SQL 命令

- **SELECT** - 从数据库中提取数据
- **UPDATE** - 更新数据库中的数据
- **DELETE** - 从数据库中删除数据
- **INSERT INTO** - 向数据库中插入新数据
- **CREATE DATABASE** - 创建新数据库
- **ALTER DATABASE** - 修改数据库
- **CREATE TABLE** - 创建新表
- **ALTER TABLE** - 变更（改变）数据库表
- **DROP TABLE** - 删除表
- **CREATE INDEX** - 创建索引（搜索键）
- **DROP INDEX** - 删除索引



## 数据库

**1. 查看现有数据库**

```text
SHOW DATABASES;
```

**2. 新建数据库**

```text
CREATE DATABASE <数据库名>;
```

**3. 选择数据库**

```text
USE <数据库名>;
```

**4. 从`.sql`文件引入SQL语句**

```text
SOURCE <.sql文件路径>;
```

**5. 删除数据库**

```text
DROP DATABASE <数据库名>;
```

## 表

**6. 查看当前数据库中的表**

```text
SHOW TABLES;
```

![img](https://pic4.zhimg.com/80/v2-d7ddbd8950efe4a2a320f4684fa03c6f_720w.jpg)

**7. 创建新表**

```text
CREATE TABLE <表名> (
    <列名1> <列类型1>,
    <列名2> <列类型2>,
    <列名3> <列类型3>,
    PRIMARY KEY (<列名1>),
    FOREIGN KEY (<列名2>) REFERENCES <表名2>(<列名2>)
);
```

主键（`PRIMARY KEY`）用来标识一条记录（一行），所以每条记录的主键值必须是唯一的。主键可以定义在多列上，这称为**联合主键（composite primary key）**。

如果我们把表视作具有某种结构的数组（例如，C语言中的struct），那么外键（`FOREIGN KEY`）可以视作指针。

例子：

```text
CREATE TABLE instructor (
    ID CHAR(5),
    name VARCHAR(20) NOT NULL,
    dept_name VARCHAR(20),
    salary NUMERIC(8,2), 
    PRIMARY KEY (ID),
    FOREIGN KEY (dept_name) REFERENCES department(dept_name));
```

在上面的例子中，我们创建了一个教员（`instructor`）表，该表的主键是ID，外键是教员所在的部门名称（`dept_name`），关联部门（`department`）表。此外，教员表还包括姓名（`name`）、薪水（`salary`）。其中，姓名有约束`NOT NULL`，表示姓名这一项不能为空。

**8. 概述表中的列**

使用如下语句查看表中的列的基本信息：

```text
DESCRIBE <表名>;
```

下图显示了一些例子：

![img](https://pic2.zhimg.com/80/v2-23727505d367e44a9c4d56d8df1f7509_720w.jpg)

**9. 在表中插入新纪录**

```text
INSERT INTO <表名> (<列名1>, <列名2>, <列名3>, …)
    VALUES (<值1>, <值2>, <值3>, …);
```

也可以省略列名（依序在所有列上插入新值）：

```text
INSERT INTO <表名>
    VALUES (<值1>, <值2>, <值3>, …);
```

**10. 在表中更新记录**

```text
UPDATE <表名>
    SET <列名1> = <值1>, <列名2> = <值2>, ...
    WHERE <条件>;
```

**11. 清空表**

```text
DELETE FROM <表名>;
```

**12. 删除表**

```text
DROP TABLE <表名>;
```

## 查询

**13. SELECT**

**SELECT**语句可以从表中选择数据：

```text
SELECT <列名1>, <列名2>, …
    FROM <表名>;
```

- 优先级

```bash
from
where
group by
select
distinct
having
order by
limit
1.找到表:from
2.拿着where指定的约束条件，去文件/表中取出一条条记录
3.将取出的一条条记录进行分组group by，如果没有group by，则整体作为一组
4.执行select（去重）
5.将分组的结果进行having过滤
6.将结果按条件排序：order by
7.限制结果的显示条数
```



以下语句选择所有内容：

```text
SELECT * FROM <表名>;
```

![img](https://pic3.zhimg.com/80/v2-7c3f80ef110ed423ae4fdbe53efe2726_720w.jpg)

选中department表和course表中的所有内容

**14. SELECT DISTINCT**

**SELECT DISTINCT**过滤掉了重复的值：

```text
SELECT DISTINCT <列名1>, <列名2>, …
    FROM <表名>;
```

![img](https://pic2.zhimg.com/80/v2-637855a8cc50ae2ca4c52b90e537cde1_720w.jpg)

**15. WHERE**

我们之前在更新记录时已经用到了**WHERE**关键字，用来指明条件。这里我们稍微详细一点地介绍下**WHERE**。

**WHERE**的条件通常是：

- 比较**文本（text）**
- 比较**数字（numbers）**
- **AND**、**OR**、**NOT**等逻辑运算

让我们来看一些例子：

```bash
1. 比较运算符：> < >= <= <> !=
2. between 80 and 100 值在80到100之间
3. in(80,90,100) 值是80或90或100
4. like 'e%'
通配符可以是%或_，
%表示任意多字符
_表示一个字符
5. 逻辑运算符：在多个条件直接可以使用逻辑运算符 and or not
#1:单条件查询
SELECT emp_name FROM employee
WHERE post='sale';
#2:多条件查询
SELECT emp_name,salary FROM employee
WHERE post='teacher' AND salary>10000;
#3:关键字BETWEEN AND
SELECT emp_name,salary FROM employee
WHERE salary BETWEEN 10000 AND 20000;

#4:关键字IS NULL(判断某个字段是否为NULL不能用等号，需要用IS)
SELECT emp_name,post_comment FROM employee
WHERE post_comment IS NULL;
SELECT emp_name,post_comment FROM employee
WHERE post_comment IS NOT NULL;
SELECT emp_name,post_comment FROM employee
WHERE post_comment=''; 注意''是空字符串，不是null
ps：
执行
update employee set post_comment='' where id=2;
再用上条查看，就会有结果了

#5:关键字IN集合查询
SELECT emp_name,salary FROM employee
WHERE salary=3000 OR salary=3500 OR salary=4000 OR salary=9000 ;
SELECT emp_name,salary FROM employee
WHERE salary IN (3000,3500,4000,9000) ;
SELECT emp_name,salary FROM employee
WHERE salary NOT IN (3000,3500,4000,9000) ;
#6:关键字LIKE模糊查询
通配符’%’
SELECT * FROM employee
WHERE emp_name LIKE 'eg%';
通配符’_’
SELECT * FROM employee
WHERE emp_name LIKE 'al__';
```



```text
SELECT * FROM course WHERE dept_name='Comp. Sci.';
SELECT * FROM course WHERE credits>3;
SELECT * FROM course WHERE dept_name='Comp. Sci.' AND credits>3;
```

![img](https://pic4.zhimg.com/80/v2-ba65cae91c8a07113428dc700a77350b_720w.jpg)

**16. GROUP BY**

```bash
单独使用GROUP BY关键字分组
SELECT post FROM employee GROUP BY post;
注意：我们按照post字段分组，那么select查询的字段只能是post，想要获取组内的其他相关信息，
需要借助函数
GROUP BY关键字和GROUP_CONCAT()函数一起使用
SELECT post,GROUP_CONCAT(emp_name) FROM employee GROUP BY post;#按照岗位分组，并查看组内成员名
SELECT post,GROUP_CONCAT(emp_name) as emp_members FROM employee GROUP BY post;
GROUP BY与聚合函数一起使用
select post,count(id) as count from employee group by post;#按照岗位分组，并查看每个组有多少人
PS:
1.如果我们用unique的字段作为分组的依据，则每一条记录自成一组，这种分组没有意义
2.多条记录之间的某个字段值相同，该字段通常用来作为分组的依据
```

**GROUP BY**语句可以分组结果，常用于**COUNT**、**MAX**、**MIN**、**SUM**、**AVG**等**聚合函数（aggregate functions）**。

```text
SELECT <列名1>, <列名2>, …
    FROM <表名>
    GROUP BY <列名>;
```

让我们来看一个例子，列出每个部门的课程数量：

```text
SELECT COUNT(course_id), dept_name 
     FROM course 
     GROUP BY dept_name; 
```

![img](https://pic2.zhimg.com/80/v2-b98b02a2e727819e0bb393dd39ea6609_720w.jpg)

- 聚合函数

```bash
#强调：聚合函数聚合的是组的内容，若是没有分组，则默认一组
示例：
SELECT COUNT(*) FROM employee;
SELECT COUNT(*) FROM employee WHERE depart_id=1;
SELECT MAX(salary) FROM employee;
SELECT MIN(salary) FROM employee;
SELECT AVG(salary) FROM employee;
SELECT SUM(salary) FROM employee;
SELECT SUM(salary) FROM employee WHERE depart_id=3;
```

**17. HAVING**

乍看起来，**HAVING**和**WHERE**很像：

```text
！！！执行优先级从高到低：where > group by > having
#1. Where 发生在分组group by之前，因而Where中可以有任意字段，但是绝对不能使用聚合函数。
#2. Having发生在分组group by之后，因而Having中可以使用分组的字段，无法直接取到其他字
段,可以使用聚合

SELECT <列名1>, <列名2>, …
    FROM <表名>
    GROUP BY <列名x>
    HAVING <条件>;
```

那么，**HAVING**和**WHERE**有什么不同呢？让我们先来看一个例子，列出开了不止一门课程的部门开设的课程数：

```text
SELECT COUNT(course_id), dept_name 
    FROM course 
    GROUP BY dept_name 
    HAVING COUNT(course_id)>1;
```

这里**HAVING**不能换成**WHERE**，因为**WHERE**直接针对行操作，且在**GROUP BY**之前运行（即先通过**WHERE**筛选行，之后再将筛选出的行通过**GROUP BY**分组）。假设SQL中不存在**HAVING**语句，那么我们只能先新建一张表，将`COUNT(course_id)`作为新表的列，然后在新表上再通过**WHERE**进行筛选（当然，实际上SQL提供了派生表、CTE等机制，并不用真的手工建新表）。

![img](https://pic4.zhimg.com/80/v2-9822a7cdbae57d65986b8760be362e63_720w.jpg)

**18. ORDER BY**

**ORDER BY**可以对结果进行排序，在没有明确指定**ASC**（升序）或**DESC**（降序）的情况下，**默认按升序排列。**

```text
SELECT <列名1>, <列名2>, …
FROM <表名>
ORDER BY <列名1>, <列名2>, …, ASC|DESC;
按单列排序
SELECT * FROM employee ORDER BY salary;
SELECT * FROM employee ORDER BY salary ASC;
SELECT * FROM employee ORDER BY salary DESC;
按多列排序:先按照age排序，如果年纪相同，则按照薪资排序
SELECT * from employee
ORDER BY age,
salary DESC;
```

例子：

```text
SELECT * FROM course ORDER BY credits;
SELECT * FROM course ORDER BY credits DESC;
```

![img](https://pic2.zhimg.com/80/v2-6671d510a7597957436428001436d695_720w.jpg)

**19. BETWEEN**

**BETWEEN**语句用于**指定区间**。

```text
SELECT <列名1>, <列名2>, …
    FROM <表名>
    WHERE <列名x> BETWEEN <值1> AND <值2>;
```

其中“值”可能是数字，文本，乃至日期等。

例如，列出薪资在50000和100000之间的教员：

```text
SELECT * FROM instructor 
    WHERE salary BETWEEN 50000 AND 100000;
```

![img](https://pic2.zhimg.com/80/v2-67fd4e97bdbac7493f10d0cea8270ba1_720w.jpg)

**20. LIKE**

**LIKE**用于匹配**文本中的特定模式**。

```text
SELECT <列名1>, <列名2>, …
    FROM <表名>
    WHERE <列名x> LIKE <模式>;
```

模式中可以使用以下两个通配符：

- `%` （零个、一个或多个字符）
- `_` （单个字符）

例子：列出课程名中包含“to”的课程，以及课程ID以“CS-”开头的课程。

```text
SELECT * FROM course WHERE title LIKE '%to%';
SELECT * FROM course WHERE course_id LIKE 'CS-___';
```

![img](https://pic4.zhimg.com/80/v2-b79387e250a3df16e27e6046e4256b6b_720w.jpg)

**21. IN**

**IN**语句表示值属于某个集合。

```text
SELECT <列名1>, <列名2>, …
    FROM <表名>
    WHERE <列名n> IN (<值1>, <值2>, …);
```

例子：列出计算机科学、物理、电子工程部门的学生。

```text
SELECT * FROM student 
    WHERE dept_name IN ('Comp. Sci.', 'Physics', 'Elec. Eng.');
```

![img](https://pic4.zhimg.com/80/v2-e3aa7ceab577f85e8f1b0676f2ec45af_720w.jpg)





## 表的约束规则

- 在 SQL 中，我们有如下约束：
  - **NOT NULL** - 指示某列不能存储 NULL 值。
  - **UNIQUE** - 保证某列的每行必须有唯一的值。
  - **PRIMARY KEY** - NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。
  - **FOREIGN KEY** - 保证一个表中的数据匹配另一个表中的值的参照完整性。
  - **CHECK** - 保证列中的值符合指定的条件。
  - **DEFAULT** - 规定没有给列赋值时的默认值。

- NOT NULL示例

```bash
mysql> create table t12 (id int not null);
Query OK, 0 rows affected (0.02 sec)
mysql> select * from t12;
Empty set (0.00 sec)
mysql> desc t12;
+-------+---------+------+-----+---------+-------+
| Field | Type | Null | Key | Default | Extra |
+-------+---------+------+-----+---------+-------+
| id | int(11) | NO | | NULL | |
+-------+---------+------+-----+---------+-------+
row in set (0.00 sec)
#不能向id列插入空元素。
mysql> insert into t12 values (null);
ERROR 1048 (23000): Column 'id' cannot be null
mysql> insert into t12 values (1);
Query OK, 1 row affected (0.01 sec)
```

- UNIQUE

```bash
方法一：
create table department1(
id int,
name varchar(20) unique,
comment varchar(100)
);
方法二：
create table department2(
id int,
name varchar(20),
comment varchar(100),
unique(name)
);
mysql> insert into department1 values(1,'IT','技术');
Query OK, 1 row affected (0.00 sec)
mysql> insert into department1 values(1,'IT','技术');
ERROR 1062 (23000): Duplicate entry 'IT' for key 'name'
```

## 1.3 [主键约束](https://so.csdn.net/so/search?q=主键约束&spm=1001.2101.3001.7020)：primary key

**1）注意：**

- 若某一列添加了该约束，则代表了非空，且唯一；
- 一张表只能有一个字段为主键；
- 主键就是表中记录的唯一标识；

2）创建表时添加主键约束

```bash
CREATE TABLE stu(
	id INT PRIMARY KEY,
	number VARCHAR(20)
);
```

3）删除主键

```sql
-- 错误方式 ALTER TABLE stu MODIFY id int;
ALTER TABLE stu DROP PRIMARY KEY;
```

4）创建完表后添加主键

```sql
ALTER TABLE stu MODIFY id INT PRIMARY KEY;
```

5）自动增长：若某一列是数值类型的，使用关键字auto_increment 可以来完成值得自动增长。

- 在创建 表时添加主键约束，且完成主键自增长

```bash
CREATE TABLE stu(
	id INT PRIMARY KEY AUTO_INCREMENT,
	number VARCHAR(20)
);
```

- 删除自动增长

```sql
ALTER TABLE stu MODIFY id INT;
```

- 创建后，添加自动增长

```sql
ALTER TABLE stu MODIFY id INT AUTO_INCREMENT;
```



## 多表连接查询

```bash
#建表
create table department(
id int,
name varchar(20)
);
create table employee2(
id int primary key auto_increment,
name varchar(20),
sex enum('male','female') not null default 'male',
age int,
dep_id int
);
#插入数据
insert into department values
(200,'技术'),
(201,'人力资源'),
(202,'销售'),
(203,'运营');
insert into employee2(name,sex,age,dep_id) values
('egon','male',18,200),
('alex','female',48,201),
('wupeiqi','male',38,201),
('yuanhao','female',28,202),
('liwenzhou','male',18,200),
('jingliyang','female',18,204)


#重点：外链接语法
SELECT 字段列表
FROM 表1 INNER|LEFT|RIGHT JOIN 表2
ON 表1.字段 = 表2.字段;
#交叉连接
MariaDB [test]> select * from employee2,department;
#内连接，交叉运算后只保留两张表都存在的记录
MariaDB [test]> select
employee2.id,employee2.name,employee2.age,employee2.sex,department.name from
employee2 inner
join department on employee2.dep_id=department.id;
MariaDB [test]> select
employee2.id,employee2.name,employee2.age,employee2.sex,department.name from
employee2,department where employee2.dep_id=department.id;
+----+-----------+------+--------+--------------+
| id | name | age | sex | name |
+----+-----------+------+--------+--------------+
| 1 | egon | 18 | male | 技术 |
| 2 | alex | 48 | female | 人力资源 |
| 3 | wupeiqi | 38 | male | 人力资源 |
| 4 | yuanhao | 28 | female | 销售 |
| 5 | liwenzhou | 18 | male | 技术 |
+----+-----------+------+--------+--------------+
#左连接，交叉运算后优先显示左表全部记录
MariaDB [test]> select employee2.id,employee2.name,department.name as
depart_name from
employee2 left join department on employee2.dep_id=department.id;
+----+------------+--------------+
| id | name | depart_name |
+----+------------+--------------+
| 1 | egon | 技术 |
| 5 | liwenzhou | 技术 |
| 2 | alex | 人力资源 |
| 3 | wupeiqi | 人力资源 |
| 4 | yuanhao | 销售 |
| 6 | jingliyang | NULL |
+----+------------+--------------+
```

## 子查询

```bash
#1：子查询是将一个查询语句嵌套在另一个查询语句中。
#2：内层查询语句的查询结果，可以为外层查询语句提供查询条件。
#3：子查询中可以包含：IN、NOT IN、ANY、ALL、EXISTS 和 NOT EXISTS等关键字
#4：还可以包含比较运算符：= 、 !=、> 、<等
```

- 带IN关键字的子查询

```bash
#查询平均年龄在25岁以上的部门名
select id,name from department
where id in
(select dep_id from employee group by dep_id having avg(age) > 25);
#查看技术部员工姓名
select name from employee
where dep_id in
(select id from department where name='技术');
#查看不足1人的部门名(子查询得到的是有人的部门id)
select name from department where id not in (select distinct dep_id from
employee);
```



# MYSQL查询练习题

```bash
#建表
create database my_db;

use my_db;

CREATE TABLE student (
    stu_id INT(10) PRIMARY KEY,
    stu_name VARCHAR(20)NOT NULL,
    sex VARCHAR(2),
    birth YEAR,
    department VARCHAR(20),
    addr VARCHAR(50)
);


INSERT INTO student VALUES
( 901,'张飞', '男',1985,'计算机系', '河北省涿州市'),
( 902,'关羽', '男',1986,'中文系', '山西省运城市'),
( 903,'貂蝉', '女',1990,'中文系', '山西省忻州县'),
( 904,'刘备', '男',1990,'英语系', '河北省涿州市'),
( 905,'小乔', '女',1991,'英语系', '安徽省潜山市'),
( 906,'赵云', '男',1988,'计算机系', '河北省正定市');

CREATE TABLE score (
    score_id INT(10) PRIMARY KEY AUTO_INCREMENT ,
    stu_id INT(10) NOT NULL ,
    c_name VARCHAR(20) ,
    grade INT(10)
);


INSERT INTO score(stu_id,c_name,grade) VALUES(901, '计算机',98),
(901, '英语', 80),(902, '计算机',65),(902, '中文',88),
(903, '中文',95),(904, '计算机',70),(904, '英语',92),
(905, '英语',94),(906, '计算机',90),(906, '英语',85);

```









# 数据类型

## 整数类型

![image-20220420214535820](http://cdn.gtrinee.top/image-20220420214535820.png)



```bash
# 创建表一个是默认宽度的int，一个是指定宽度的int(5)
mysql> create table t1 (id1 int,id2 int(5));
Query OK, 0 rows affected (0.02 sec)
# 像t1中插入数据1，1
mysql> insert into t1 values (1,1);
Query OK, 1 row affected (0.01 sec)
# 可以看出结果上并没有异常
mysql> select * from t1;
+------+------+
| id1 | id2 |
+------+------+
| 1 | 1 |
+------+------+
row in set (0.00 sec)
# 那么当我们插入了比宽度更大的值，会不会发生报错呢？
mysql> insert into t1 values (111111,111111);
Query OK, 1 row affected (0.00 sec)
# 答案是否定的，id2仍然显示了正确的数值，没有受到宽度限制的影响
mysql> select * from t1;
+------------+--------+
| id1 | id2 |
+------------+--------+
| 0000000001 | 00001 |
| 0000111111 | 111111 |
+------------+--------+
rows in set (0.00 sec)
# 修改id1字段 给字段添加一个unsigned表示无符号
mysql> alter table t1 modify id1 int unsigned;
Query OK, 0 rows affected (0.01 sec)
Records: 0 Duplicates: 0 Warnings: 0
mysql> desc t1;
+-------+------------------+------+-----+---------+-------+
| Field | Type | Null | Key | Default | Extra |
+-------+------------------+------+-----+---------+-------+
| id1 | int(10) unsigned | YES | | NULL | |
| id2 | int(5) | YES | | NULL | |
+-------+------------------+------+-----+---------+-------+
rows in set (0.01 sec)
# 当给id1添加的数据大于214748364时，可以顺利插入
mysql> insert into t1 values (2147483648,2147483647);
Query OK, 1 row affected (0.00 sec)
# 当给id2添加的数据大于214748364时，会报错
mysql> insert into t1 values (2147483647,2147483648);
ERROR 1264 (22003): Out of range value for column 'id2' at row 1
```

# 日期时间类型

![image-20220420223502579](http://cdn.gtrinee.top/image-20220420223502579.png)

data/time/datatime示例

```bash
mysql> create table t4 (d date,t time,dt datetime);
Query OK, 0 rows affected (0.02 sec)
mysql> desc t4;
+-------+----------+------+-----+---------+-------+
| Field | Type | Null | Key | Default | Extra |
+-------+----------+------+-----+---------+-------+
| d | date | YES | | NULL | |
| t | time | YES | | NULL | |
| dt | datetime | YES | | NULL | |
+-------+----------+------+-----+---------+-------+
rows in set (0.01 sec)
mysql> insert into t4 values (now(),now(),now());
Query OK, 1 row affected, 1 warning (0.01 sec)
mysql> select * from t4;
+------------+----------+---------------------+
| d | t | dt |
+------------+----------+---------------------+
| 2018-09-21 | 14:51:51 | 2018-09-21 14:51:51 |
+------------+----------+---------------------+
row in set (0.00 sec)
mysql> insert into t4 values (null,null,null);
Query OK, 1 row affected (0.01 sec)
mysql> select * from t4;
+------------+----------+---------------------+
| d | t | dt |
+------------+----------+---------------------+
| 2018-09-21 | 14:51:51 | 2018-09-21 14:51:51 |
| NULL | NULL | NULL |
+------------+----------+---------------------+
rows in set (0.00 sec)
```

# 字符串类型

![image-20220420223542355](http://cdn.gtrinee.top/image-20220420223542355.png)s``

```bash
mysql> create table t9 (v varchar(4),c char(4));
Query OK, 0 rows affected (0.01 sec)
mysql> insert into t9 values ('ab ','ab ');
Query OK, 1 row affected (0.00 sec)
# 在检索的时候char数据类型会去掉空格
mysql> select * from t9;
+------+------+
| v | c |
+------+------+
| ab | ab |
+------+------+
row in set (0.00 sec)
# 来看看对查询结果计算的长度
mysql> select length(v),length(c) from t9;
+-----------+-----------+
| length(v) | length(c) |
+-----------+-----------+
| 4 | 2 |
+-----------+-----------+
row in set (0.00 sec)
# 给结果拼上一个加号会更清楚
mysql> select concat(v,'+'),concat(c,'+') from t9;
+---------------+---------------+
| concat(v,'+') | concat(c,'+') |
+---------------+---------------+
| ab + | ab+ |
+---------------+---------------+
row in set (0.00 sec)
# 当存储的长度超出定义的长度，会截断
mysql> insert into t9 values ('abcd ','abcd ');
Query OK, 1 row affected, 1 warning (0.01 sec)
mysql> select * from t9;
+------+------+
| v | c |
+------+------+
| ab | ab |
| abcd | abcd |
+------+------+
rows in set (0.00 sec)
```

# 索引管理

- 功能

```bash
1. 索引的功能就是加速查找
在关系数据库中，索引是一种单独的、物理的对数据库表中一列或多列的值进行排序的一种存储结构，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单。索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。
2. mysql中的primary key，unique，联合唯一也都是索引，这些索引除了加速查找以外，还有约束的功能
```

- 常用索引

```bash
普通索引INDEX：加速查找
唯一索引：
-主键索引PRIMARY KEY：加速查找+约束（不为空、不能重复）
-唯一索引UNIQUE:加速查找+约束（不能重复）
联合索引：
-PRIMARY KEY(id,name):联合主键索引
-UNIQUE(id,name):联合唯一索引
-INDEX(id,name):联合普通索引


#索引类型
#我们可以在创建上述索引的时候，为其指定索引类型，分两类
hash类型的索引：查询单条快，范围查询慢
btree类型的索引：b+树，层数越多，数据量指数级增长（我们就用它，因为innodb默认支持它）
#不同的存储引擎支持的索引类型也不一样
InnoDB 支持事务，支持行级别锁定，支持 B-tree、Full-text 等索引，不支持
#方法一：创建表时
CREATE TABLE 表名 (
字段名1 数据类型 [完整性约束条件…],
字段名2 数据类型 [完整性约束条件…],
[UNIQUE | FULLTEXT | SPATIAL ] INDEX | KEY
[索引名] (字段名[(长度)] [ASC |DESC])
);
#方法二：CREATE在已存在的表上创建索引
CREATE [UNIQUE | FULLTEXT | SPATIAL ] INDEX 索引名
ON 表名 (字段名[(长度)] [ASC |DESC]) ;
#方法三：ALTER TABLE在已存在的表上创建索引
ALTER TABLE 表名 ADD [UNIQUE | FULLTEXT | SPATIAL ] INDEX
索引名 (字段名[(长度)] [ASC |DESC]) ;
#删除索引：DROP INDEX 索引名 ON 表名字; 索引；
MyISAM 不支持事务，支持表级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引；
Memory 不支持事务，支持表级别锁定，支持 B-tree、Hash 等索引，不支持 Full-text 索引；
NDB 支持事务，支持行级别锁定，支持 Hash 索引，不支持 B-tree、Full-text 等索引；
Archive 不支持事务，支持表级别锁定，不支持 B-tree、Hash、Full-text 等索引；
```

## 索引的使用

```bash
#方法一：创建表时
CREATE TABLE 表名 (
字段名1 数据类型 [完整性约束条件…],
字段名2 数据类型 [完整性约束条件…],
[UNIQUE | FULLTEXT | SPATIAL ] INDEX | KEY
[索引名] (字段名[(长度)] [ASC |DESC])
);
#方法二：CREATE在已存在的表上创建索引
CREATE [UNIQUE | FULLTEXT | SPATIAL ] INDEX 索引名
ON 表名 (字段名[(长度)] [ASC |DESC]) ;
#方法三：ALTER TABLE在已存在的表上创建索引
ALTER TABLE 表名 ADD [UNIQUE | FULLTEXT | SPATIAL ] INDEX
索引名 (字段名[(长度)] [ASC |DESC]) ;
#删除索引：DROP INDEX 索引名 ON 表名字;
```

- 示例

```bash
#方式一
create table t1(
id int,
name char,
age int,
sex enum('male','female'),
unique key uni_id(id),
index ix_name(name) #index没有key
);
create table t1(
id int,
name char,
age int,
sex enum('male','female'),
unique key uni_id(id),
index(name) #index没有key
);
#方式二
create index ix_age on t1(age);
#方式三
alter table t1 add index ix_sex(sex);
alter table t1 add index(sex);
#查看
mysql> show create table t1;
| t1 | CREATE TABLE `t1` (
`id` int(11) DEFAULT NULL,
`name` char(1) DEFAULT NULL,
`age` int(11) DEFAULT NULL,
`sex` enum('male','female') DEFAULT NULL,
UNIQUE KEY `uni_id` (`id`),
KEY `ix_name` (`name`),
KEY `ix_age` (`age`),
KEY `ix_sex` (`sex`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1
```

- 测试索引

```bash
#1. 准备表
create table s1(
id int,
name varchar(20),
gender char(6),
email varchar(50)
);
#2. 创建存储过程，实现批量插入记录
delimiter $$ #声明存储过程的结束符号为$$
create procedure auto_insert2()
BEGIN
declare i int default 1;
while(i<3000000)do
insert into s1 values(i,'eva','female',concat('eva',i,'@eagleslab'));
set i=i+1;
end while;
END$$ #$$结束
delimiter ; #重新声明分号为结束符号
#3. 查看存储过程
show create procedure auto_insert2\G
#4. 调用存储过程
call auto_insert2();
#没有索引
select * from s1 where id=333333333;
#建立索引
create index a on s1(id);
#查询测试
select * from s1 where id=333333333;
#补充
1.mysql先去索引表里根据b+树的搜索原理很快搜索到id等于333333333的记录不存在，IO大大降
低，因而速度明
显提升
2.我们可以去mysql的data目录下找到该表，可以看到占用的硬盘空间多了
3.如果我们通过email查询，速度依旧很慢，因为没有对eamil创建索引
```

# SQL模型

如何查看并修改sql模型？

```bash
SELECT @@[GLOBAL | SESSION].sql_mode; 显示值
set GLOBAL | SESSION sql_mode=[值]; 修改值
```

# 优化性能相关

```bash
1. 一定是为搜索条件的字段创建索引，比如select * from s1 where id = 333;就需要为id加上索引
2. 在表中已经有大量数据的情况下，建索引会很慢，且占用硬盘空间，建完后查询速度加快
比如create index idx on s1(id);会扫描表中所有的数据，然后以id为数据项，创建索引结构，存放于硬盘的表中。
建完以后，再查询就会很快了。
3. 需要注意的是：innodb表的索引会存放于s1.ibd文件中，而myisam表的索引则会有单独的索引文件
table1.MYI
MySAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在innodb中，表数据文件本身就是按照
B+Tree（BTree即Balance True）组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此innodb表数据文件本身就是主索引。
因为inndob的数据文件要按照主键聚集，所以innodb要求表必须要有主键（Myisam可以没有），如果没有显式定义，则mysql系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则mysql会自动为
innodb表生成一个隐含字段作为主键，这字段的长度为6个字节，类型为长整型.
```

![image-20220420235718437](http://cdn.gtrinee.top/image-20220420235718437.png)

# 事务

**事务包含一个或多个业务操作，这些操作要么都执行，要么都不执行。事务常被用来确保数据的一致性。**

**什么是事务？**
事务：是**数据库操作的最小工作单元**，是作为单个逻辑工作单元执行的一系列操作；**这些操作作为一个整体一起向系统提交，要么都执行、要么都不执行；事务是一组不可再分割的操作[集合](https://so.csdn.net/so/search?q=集合&spm=1001.2101.3001.7020)**（工作逻辑单元）；

```bash
1.数据库事务: 数据库事务通常指对数据库进行读或写的一个操作序列。
    它的存在包含有以下两个目的：
    1、为数据库操作提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。
    2、当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。
2.系统中的事务: 处理一系列业务处理的执行逻辑单元,该单元里的一系列类操作要不全部成功要不全部失败
```

## 特点

- 把数据库从一种一致性状态转换为另一种一致性状态，来保证数据库的完整性 
- 主要用于处理操作量大，复杂高的数据 
- 在MySQL中只有使用了Innodb数据库引擎的数据库或表才支持事务 
- 事务处理可以用来维护数据库的完整性，保证成批的sql语句要么全部执行，要么全部不执行。全部执行称为事务提交，全部不执行称为事务回滚。
-  事务主要用于管理insert、update、delete

### 事务的特点 ACID

- **原子性（Atomicity）**：一个事务**是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。**
- **一致性（Consistency**）：事务必须是使数据库从一个一致性状态变到另一个一致性状态。**一致性与原子性是密切相关的**。
- **隔离性（Isolation）**：**一个事务的执行不能被其他事务干扰。**即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。
- **持久性（Durability**）：持久性也称永久性（permanence）**，指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。**接下来的其他操作或故障不应该对其有任何影响。

## 事务的隔离级别

- read uncommitted（未提交读）：出现脏读的现象
- read conmitted （提交读）：能够解决脏读，修改数据时会加锁。会出现幻读现象 
- repeatable read （可重读）：能够解决幻读现象 
- serializable（可串行化读）：事务需要按串行化解决（MVCC）

> 隔离级别比较：可串行化>可重复读>读已提交>读未提交
>
> 隔离级别对性能的影响比较：可串行化>可重复读>读已提交>读未提交
>
> 由此看出，隔离级别越高，所需要消耗的MySQL性能越大（如事务并发严重性），为了平衡二者，一般建议设置的隔离级别为可重复读，MySQL默认的隔离级别也是可重复读。

#### 脏读（Dirty Read）

> 一个事务读到了另一个未提交事务修改过的数据



#### 不可重复读（Non-Repeatable Read）

> 一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值。（不可重复读在读未提交和读已提交隔离级别都可能会出现）

#### 幻读（Phantom）

> 一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来。（幻读在读未提交、读已提交、可重复读隔离级别都可能会出现）

Innodb存储引擎默认可重复读

```bash
mysql>begin； ＃开始一个事务
mysql>insert into a (a) values(555);
mysql>rollback; #回滚，这样数据是不会写入的
mysql>commit; #提交事务
```

事务案例

- 创建一个表并插入数据

```bash
MariaDB [db1]> create table user(id int primary key auto_increment,memory
int unsigned);
Query OK, 0 rows affected (0.00 sec)

MariaDB [db1]> insert into user values (0,500), (0,100), (0,0);
Query OK, 3 rows affected (0.00 sec)

Records: 3 Duplicates: 0 Warnings: 0
MariaDB [db1]> select * from user;
+----+--------+
| id | memory |
+----+--------+
| 1 | 500 |
| 2 | 100 |
| 3 | 0 |
+----+--------+
3 rows in set (0.00 sec)
```

- 查看事务变量

```bash
MariaDB [db1]> show variables like '%commit%';
+-------------------------------------------+-------+
| Variable_name | Value |
+-------------------------------------------+-------+
| aria_group_commit | none |
| aria_group_commit_interval | 0 |
| autocommit | ON |
| innodb_commit_concurrency | 0 |
| innodb_flush_log_at_trx_commit | 1 |
| innodb_use_global_flush_log_at_trx_commit | ON |
+-------------------------------------------+-------+
6 rows in set (0.00 sec)
# 如果需要关闭自动提交的话可以在会话端通过 set autocommit=0或者在配置文件中添加参数
autocommit=0
```

- 开启事务，开启事务时不会自动提交，操作处于内存当中

```bash
MariaDB [db1]> begin;
Query OK, 0 rows affected (0.00 sec)

MariaDB [db1]> update user set memory=memory - 250 where id = 1;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1 Changed: 1 Warnings: 0

MariaDB [db1]> select * from user;
+----+--------+
| id | memory |
+----+--------+
| 1 | 250 |
| 2 | 100 |
| 3 | 0 |
+----+--------+
3 rows in set (0.01 sec)

MariaDB [db1]> rollback;
Query OK, 0 rows affected (0.00 sec)

MariaDB [db1]> select * from user;
+----+--------+
| id | memory |
+----+--------+
| 1 | 500 |
| 2 | 100 |
| 3 | 0 |
+----+--------+
3 rows in set (0.00 sec)
```

- 同时开启两个事务，另一个事务会卡住，这是事务的隔离性决定的

```bash
MariaDB [db1]> begin;
Query OK, 0 rows affected (0.00 sec)
MariaDB [db1]> update user set memory=memory - 250 where id = 1;
Query OK, 1 row affected (0.01 sec)
Rows matched: 1 Changed: 1 Warnings: 0
```

# 范式

[(17条消息) MySQL三大范式详解(小白也能懂哦)_「已注销」的博客-CSDN博客_mysql三大范式](https://blog.csdn.net/qq_45737068/article/details/106185907)



# 日志管理

## 错误日志（log_error）

错误日志是用来记录MySQL数据库的启动、关闭、日常运行过程中、状态信息、警告、错误等信息

- 查看错误日志的文件位置

```bash
MariaDB [(none)]> show variables like 'log_error';
+---------------+------------------------------+
| Variable_name | Value |
+---------------+------------------------------+
| log_error | /var/log/mariadb/mariadb.log |
+---------------+------------------------------+
1 row in set (0.00 sec)
```

## 二进制日志（binlog）

备份恢复必须以来二进制日志，主从环境必须以来二进制日志。binlog是SQL层的功能，记录的是变更 的sql语句，不记录查询语句

- 开启二进制日志

```bash
vim /etc/my.cnf
server_id=6 # 设置id
log_bin=mysql-bin # 开启并指定二进制日志目录及前缀名，记得关闭
selinux
binlog_format=row # binlog的日志记录格式
修改完配置重启服务会自动生成二进制日志
```

- 日志记录方式
  - SBR(statement based replication) ：语句模式原封不动的记录当前DML，5.6默认。
  - RBR(ROW based replication) ：记录数据行的变化(用户看不懂，需要工具分析)，5.7默认。 
  - mixed（混合）MBR(mixed based replication)模式 ：以上两种模式的混合

- SBR模式与RBR模式的对比（面试题）
  - SBR：可读性较高，日志量少，但是不够严谨
  - ROW：可读性很低，日志量大，足够严谨（建议使用）



- event事件简介

```bash
二进制日志的最小记录单元
对于DDL,DCL,一个语句就是一个event
对于DML语句来讲:只记录已提交的事务。
例如以下列子,就被分为了4个event
begin; 120 - 340
DML1 340 - 460
DML2 460 - 550
commit; 550 - 760
```

- 查看日志的开启情况

```bash
MariaDB [(none)]>show variables like '%log_bin%';
+---------------------------------+------------------------------+
| Variable_name | Value |
+---------------------------------+------------------------------+
| log_bin | ON |
| log_bin_basename | /data/binlog/mysql-bin |
| log_bin_index | /data/binlog/mysql-bin.index |
| log_bin_trust_function_creators | OFF |
| log_bin_use_v1_row_events | OFF |
| sql_log_bin | ON |
+---------------------------------+------------------------------+
6 rows in set (0.01 sec)
```

- 日志内容查看

```bash
MariaDB [binlog]>show binlog events in 'mysql-bin.000003';
+------------------+-----+----------------+-----------+-------------+-------
---------------------------------+
| Log_name | Pos | Event_type | Server_id | End_log_pos | Info
|
+------------------+-----+----------------+-----------+-------------+-------
---------------------------------+
| mysql-bin.000003 | 4 | Format_desc | 6 | 123 | Server
ver: 5.7.20-log, Binlog ver: 4 |
| mysql-bin.000003 | 123 | Previous_gtids | 6 | 154 |
|
| mysql-bin.000003 | 154 | Anonymous_Gtid | 6 | 219 | SET
@@SESSION.GTID_NEXT= 'ANONYMOUS' |
| mysql-bin.000003 | 219 | Query | 6 | 319 | create
database binlog |
| mysql-bin.000003 | 319 | Anonymous_Gtid | 6 | 384 | SET
@@SESSION.GTID_NEXT= 'ANONYMOUS' |
| mysql-bin.000003 | 384 | Query | 6 | 486 | use
`binlog`; create table t1 (id int) |
+------------------+-----+----------------+-----------+-------------+-------
---------------------------------+
Log_name：binlog文件名
Pos：开始的position *****
Event_type：事件类型
Format_desc：格式描述，每一个日志文件的第一个事件，多用户没有意义，MySQL识别binlog必要
信息
Server_id：mysql服务号标识
End_log_pos：事件的结束位置号 *****
Info：事件内容*****
补充:
SHOW BINLOG EVENTS
[IN 'log_name']
[FROM pos]
[LIMIT [offset,] row_count]
```



## 案例，使用二进制日志文件进行恢复数据

- 故障模拟

```bash
创建了一个库 db, 导入了表t1 ,t1表中录入了很多数据
一个开发人员,drop database db;
没有备份,日志都在.怎么恢复?
思路:找到建库语句到删库之前所有的日志,进行恢复.(开启了GTID模式)
故障案例模拟:
(0) drop database if exists db ;
(1) create database db charset utf8;
(2) use db;
(3) create table t1 (id int);
(4) insert into t1 values(1),(2),(3);
(5) insert into t1 values(4),(5),(6);
(6) commit
(7) update t1 set id=30 where id=3;
(8) commit;
(9) delete from t1 where id=4;
(10)commit;
(11)insert into t1 values(7),(8),(9);
(12)commit;
(13)drop database db;
========================
drop database if exists db ;
create database db charset utf8;
use db;
create table t1 (id int);
insert into t1 values(1),(2),(3);
insert into t1 values(4),(5),(6);
commit;
update t1 set id=30 where id=3;
commit;
delete from t1 where id=4;
commit;
insert into t1 values(7),(8),(9);
commit;
drop database db;
=======
运行以上语句，模拟故障场景
需求：将数据库恢复到以下状态（提示第9步和第13步是误操作，其他都是正常操作）
```

- 查看正在使用的二进制日志

```bash
MariaDB [(none)]> show master status ;
......
mysql-bin.000006
......

#日志截取
[root@localhost ~]# mysqlbinlog --start-position=1568 --stop-position=1762
/data/mysql/mysql-bin.000006 >/tmp/bin2.sql
#恢复
MariaDB [(none)]> set sql_log_bin=0; # 恢复过程临时关闭日志记录
MariaDB [(none)]> source /tmp/bin1.sql
MariaDB [(none)]> source /tmp/bin2.sql
MariaDB [(none)]> set sql_log_bin=1;
```

## 慢日志slow_log

慢日志文件是记录运行比较慢的sql语句，将这些sql语句记录下来以便进一步优化。可以自行补充一些 关于慢日志的分析。

- 修改配置文件开启慢日志

```bash
开关:
slow_query_log=1
文件位置及名字
slow_query_log_file=/data/mysql/slow.log
设定慢查询时间:
long_query_time=0.1
没走索引的语句也记录:
log_queries_not_using_indexes
[root@localhost ~]# vim /etc/my.cnf
    slow_query_log=1
    slow_query_log_file=/data/mysql/slow.log
    long_query_time=0.1
    log_queries_not_using_indexes
[root@localhost ~]# systemctl restart mysqld

```



# 备份与恢复

## 备份方式

- 按照备份数据位置分类
  - 热备：硬盘以及内存中一些数据进行备份
  - 冷备:   数据库硬盘中的数据
- 按照备份后文件的内容
  - 逻辑备份：一般内容分是sql语句
  - 裸文件备份：拷贝数据库的物理文件，一般内容是二进制数据
- 按照备份数据的内容
  - 完全备份：对数据库进行一个完整的备份
  - 增量备份：在上次的完全备份对更新的数据进行备份
  - 日志备份：⼆进制⽇志备份-->当数据库宕机之后进⾏数据恢复的依据
- 冷备份的优点：
  -  备份简单，只要拷⻉相关⽂件即可 
  - 易于跨平台 
  - 恢复简单，只要把⽂件恢复到相关位置即可 
  - 恢复速度快，不需要执⾏任何sql语句，也不需要重新建索引 
- 冷备份缺点 ：
  - 冷备⽂件通常⽐逻辑⽂件⼤很多 
  - 不是总可以轻易跨平台 
- 逻辑备份：
-  mysqldump 
- selcet * into outfile 'path/to/file' from tbname;

## 使用mysqldump工具备份

要备份整个数据库，请执行以下命令：

```

mysqldump -u [username] -p [database_name] > [backup_file].sql
```

其中：

- `[username]`：登录数据库的用户名。
- `[database_name]`：要备份的数据库的名称。
- `[backup_file].sql`：备份文件的文件名。



- mysqldump备份数据库的原理是把数据（包括库表）从MySQL库里**以sql语句的形式**直接输出或者 生产备份文件的过程，这种备份成sql的方式称为逻辑备份。

```
参数 		解释
-B 		可以同时接多个库名，备份多个库
-A 		备份所有的数据库
-d 		只备份表结构，没有行数据
-t 		只备份行数据，没有表结构
-F 		刷新binlog
-l 		锁定所有的表为只读
```

- 不带参数备份单个数据库

```bash
[root@localhost ~]# mysqldump test > test_db_bak.sql
# 可以打开看看备份的数据
[root@localhost ~]# cat test_db_bak.sql | grep -Ev "#|\*|--|^$"
DROP TABLE IF EXISTS `test_tb`;
CREATE TABLE `test_tb` (
`id` int(11) DEFAULT NULL,
`name` char(20) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=gb2312;
LOCK TABLES `test_tb` WRITE;
INSERT INTO `test_tb` VALUES (1,'??'),(2,'lisi'),(4,'尼古拉赵四'),(3,'王二麻'),(5,'谢大脚'),(6,'谢广坤');
UNLOCK TABLES;
[root@localhost ~]#
```

- 使用gzip压缩备份数据

```bash
[root@localhost ~]# mysqldump -B test | gzip> test_db_bak.sql.gz
[root@localhost ~]# ll -h
总用量 12K
-rw-------. 1 root root 1.4K 12月 2 15:04 anaconda-ks.cfg
-rw-r--r--. 1 root root 2.1K 12月 3 23:33 test_db_bak.sql
-rw-r--r--. 1 root root 824 12月 3 23:38 test_db_bak.sql.gz
```

- 备份多个表或者多个表

```bash
# 备份单个表
mysqldump 数据库名 表名 > 备份文件名
# 备份多个表
mysqldump 数据库名 表名1 表名2 … > 备份文件名
```

## 恢复

- 将sql语句重新执行一遍，则完成数据恢复 
- 可以选择在客户端使用客户端工具运行sql脚本
- 可以在数据库服务器里面执行source命令；

# 主从复制原理

在实际的生产中，为了解决**Mysql的单点故障已经提高MySQL的整体服务性能**，一般都会采用**「主从复制」**。

比如：在复杂的业务系统中，有一句sql执行后导致锁表，并且这条sql的的执行时间有比较长，那么此sql执行的期间导致服务不可用，这样就会严重影响用户的体验度。

主从复制中分为**「主服务器（master）「和」从服务器（slave）」**，**「主服务器负责写，而从服务器负责读」**，Mysql的主从复制的过程是一个**「异步的过程」**。

这样读写分离的过程能够是整体的服务性能提高，即使写操作时间比较长，也不影响读操作的进行。

## 复制过程

![img](https://pic4.zhimg.com/80/v2-12f36a0aa2ea88020809173182e54e73_720w.jpg)

1. 主服务器上任何的更新操作会被写入到二进制日志文件中 
   - 并且，Master会创建`log dump`线程通知Slave主库中存在数据更新，这就是为什么主库的binlog日志一定要开启的原因。
2. 从服务器上的IO线程： 
   1.  检测主服务器的二进制日志文件的变化 
   2.  同步主服务器的二进制日志文件到本地的**relay log（中继日志）**中 
3. 从服务器上的sql线程负责读取和执行中继日志中的sql语句

SQL线程也是在Slave中创建的，当Slave检测到中继日志有更新，就会将更新的内容同步到Slave数据库中，这样就保证了主从的数据的同步。

以上就是主从复制的过程，当然，主从复制的过程有不同的策略方式进行数据的同步，主要包含以下几种：

1. **「同步策略」**：Master会等待所有的Slave都回应后才会提交，这个主从的同步的性能会严重的影响。
2. **「半同步策略」**：Master至少会等待一个Slave回应后提交。
3. **「异步策略」**：**Master不用等待Slave回应就可以提交。**
4. **「延迟策略」**：Slave要落后于Master指定的时间。

### 实验

主库相关操作

- 修改配置文件

```bash
[root@server2 ~]# cat /etc/my.cnf
[mysqld]
......
server_id =1
log_bin=mysql-bin
......
[root@server2 ~]# systemctl restart mariadb.service
```

- 创建主从复制用户

```bash
[root@server2 ~]# mysql -uroot -p1
MariaDB [(none)]> grant replication slave on *.* to rep@'192.168.80.%'
identified by '123456'
```

- 记录主库位置点

```bash
MariaDB [(none)]> show master status;
+------------------+----------+--------------+------------------+
| File | Position | Binlog_Do_DB | Binlog_Ignore_DB |
+------------------+----------+--------------+------------------+
| mysql-bin.000001 | 395 | | |
+------------------+----------+--------------+------------------+
1 row in set (0.00 sec)
```

从库相关操作

- 修改从库配置文件

```bash
[root@server3 ~]# cat /etc/my.cnf
......
server_id =5
......
[root@server3 ~]# systemctl restart mariadb.service
```



